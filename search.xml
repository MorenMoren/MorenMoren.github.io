<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>《C++Primer》学习笔记（第二章）</title>
    <url>/2020/04/13/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<hr>
<p>2020.4.13写：</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>初始化列表（initialize list）：</li>
</ul>
<p>如以下4个初始化是等价的：</p>
<p>​    int i = 0 ;</p>
<p>​    int i = {0} ;</p>
<p>​    int i{0} ;</p>
<p>​    int i(0) ;</p>
<ul>
<li>变量的声明：</li>
</ul>
<p>​    当我们仅仅是想声明一个变量，而非去定义，我们可以用extern来完成，而当我们用extern去声明一个变量时，我们如果给它初始值，那么extern也就没有意义了。</p>
<ul>
<li>全局变量：</li>
</ul>
<p>​    当我们在函数体外定义了一个全局变量，如果我们在函数体再次定义了该变量，那么在函数体定义的变量会覆盖该全局变量，而不是去修改它。</p>
<p>​    而如果我们想要显式的访问全局变量而不是局部变量，那么我们就要如此调用      ‘ : :i ’。此处：：便是作用域操作符。</p>
<h4 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h4><p>​    引用可以给对象起一个别名，但是该引用本身并不是一个对象。然而引用要注意以下几点：</p>
<pre><code>1. 引用类型必须初始化。因为引用与一个对象绑定以后，不能再改变绑定对象。
 2. 引用类型必须与对象的类型一致，否则会出错。
 3. 引用类型的初始值必须是一个对象。假如你给一个int类型的引用赋予10，那么系统就会报错。
</code></pre><h4 id="指针："><a href="#指针：" class="headerlink" title="指针："></a>指针：</h4><ol>
<li><p>当我们想要将一个指针初始化为空指针，在C语言中我们学过，可以使用NULL（预处理变量）进行初始化，如此那和用0初始化指针本质上没有区别。</p>
<p>所以在C++上，我们更倾向于用 <strong>nullptr</strong> 来将指针初始化为空指针。</p>
</li>
<li><p><strong>void*</strong>是一个特殊的指针类型，它可以存放任意对象的地址，然而我们一般不拿<strong>void*</strong>指针所指的变量来进行比较，因为我们并不知道它所指的对象是什么类型。概括来说，以<strong>void*</strong>的视角看内存空间也仅仅是内存空间，它没办法访问内存空间所存的变量。</p>
</li>
</ol>
<h4 id="const与constexpr-const-expression-限定符："><a href="#const与constexpr-const-expression-限定符：" class="headerlink" title="const与constexpr(const expression) 限定符："></a>const与constexpr(const expression) 限定符：</h4><p>​    const限定符的主要意图就是不想我们在初始化一个变量后再去改变它，所以用const修饰一个变量时，一定要去初始化该变量。</p>
<p>​    默认情况下，const 对象被设定为仅在文件内有效，当多个文件出现同名的const 变量时，等同于在不同文件定义了独立的变量。而如果我们想在多个文件中使用同一个变量，那么我们只要在声明和定义 const 变量的前面加上 extern 就行了。</p>
<ol>
<li><p><strong>const的引用：</strong></p>
<ol>
<li><ol>
<li>​    我们允许将const的引用与非const的对象绑定，那么此处引用的意义就是，我们无法通过该引用来修改所绑定对象的值，但我们可以通过其它途径去修改。当然，如果反过来，我们就不可以将非const的引用与const的对象绑定。</li>
</ol>
</li>
<li><ol>
<li><p>​    如果一个常量引用与一个不同类型变量绑定会发生什么：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;  <span class="comment">//此处是double类型，而引用是int类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure>
<p>​    如此，编译器就会生成一个临时量对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;  <span class="comment">//将double转化为整形常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>指针和const :</strong></p>
<p>2.1. <strong>顶层const与底层const:</strong></p>
<p>​        <strong>顶层const</strong>: 即指针本身就是个常量（如int *const i）,即它不能改变它所存储的地址，即它不能改变它所指的对象。</p>
<p>​        <strong>底层const</strong>: 即指针所指的对象是个常量（如const int *i）,即它不能改变它所指的对象的值。</p>
<p>​    在执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中顶层的const（如int *const i）不受什么影响。而底层const的限制往往不能忽略。即拷入与拷出的对象必须具有相同的底层const资格，或者数据类型能转换。</p>
<p>​    一般来说，非常量可以转换为常量，反之不行。</p>
</li>
<li><p>constexpr 和常量表达式：</p>
<p>​    我们有时很难分辨一个初始值是不是常量表达式。如此，在C++11新标准规定中，允许将变量定义为constexpr,来让编译器验证初始值是否是常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;  <span class="comment">//20是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>;	<span class="comment">//mf+1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = <span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//只有当size是一个constexpr函数才是正确的声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新标准允许定义特殊的constexpr函数</span></span><br><span class="line"><span class="comment">//这个函数要求足够简单到编译时就能得到结果</span></span><br></pre></td></tr></table></figure>
<p>用const和用constexpr限定指针时，含义有所不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;	<span class="comment">//p1是指向'整型常量'的指针。底层const</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p2 = <span class="literal">nullptr</span>	<span class="comment">//p2是指向'整型'的常量指针。顶层const</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习笔记（一）：牛顿迭代法（计算平方根）</title>
    <url>/2020/04/11/%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>​    在算法（第四版）的13页里，我看到了一个的函数，它利用了牛顿迭代法来计算一个数的近似平方根，我通过查询资料理解了牛顿迭代法的实现过程。</p>
<p>​    这个方法所包含的知识：</p>
<p><em>1.导数的含义</em></p>
<p><em>2.极限的思维</em></p>
<p><em>3.函数的零点</em></p>
<h4 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h4><p>1.在求一个函数零点时，我们可以随意取一个点作为起始点(x0,f(x0)），并过该点做函数的切线,设切线的横截距为x1。在该点（x1,0）垂直于X轴引垂线，交函数于(x1,f(x1)),再对该点做与之前同样的操作，以此往复。如下图：</p>
<p><img src="http://q86xw0tu1.bkt.clouddn.com/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%9B%BE%E8%A7%A3.gif" alt="牛顿迭代法"></p>
<p>2.对所得到的数据进行处理,经过运算，第一条切线的横截距，多条切线横截距为:</p>
<script type="math/tex; mode=display">
x_1=x_0+f(x_0)/f'(x_0)\\
x_2=x_1+f(x_1)/f'(x_1)\\
.......\\
x_(n+1)=x_n+f(x_n)/f'(x_n)</script><h4 id="利用牛顿迭代法来求一个数的平方根"><a href="#利用牛顿迭代法来求一个数的平方根" class="headerlink" title="利用牛顿迭代法来求一个数的平方根"></a>利用牛顿迭代法来求一个数的平方根</h4><p>1.假设：</p>
<script type="math/tex; mode=display">
t=\sqrt[2]n\\
则设f(x)=x^2-n\\
可设x_0=n</script><p>2.利用代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> t;</span><br><span class="line">	t=n;</span><br><span class="line">	<span class="keyword">while</span>(t-n/t&lt;=<span class="number">1e-15</span>*t)</span><br><span class="line">        <span class="comment">//这里跳出循环的条件是你所要求的精度，即1-n/t^2要满足一定精度。</span></span><br><span class="line">		t=(t+n/t);</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法（第四版）</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学生管理系统（持续更新）</title>
    <url>/2020/04/08/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    <content><![CDATA[<p>​    最近一直在学习C++，就想着用C++语言自己做一个程序，就先从最简单的开始吧——学生管理系统（随着我的能力提高会逐步完善该程序）</p>
<p><strong>大致思路</strong>（<strong>利用思维导图给出</strong>）：</p>
<p><img src="http://q86xw0tu1.bkt.clouddn.com/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B01.png" alt="大致思路"></p>
<p><em>源码如下：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu_data</span> &#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="built_in">string</span> sex;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">&#125;Data;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Data data;</span><br><span class="line">	Student* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linklist</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	Student* head;</span><br><span class="line">	Student* rear;      <span class="comment">//作为末节点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Linklist();</span><br><span class="line">	~Linklist();</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Createlist</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="built_in">string</span> name,<span class="built_in">string</span> sex,<span class="keyword">int</span> num,Student**rear)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Showlist</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		利用函数的重载来对不同类型的输入对象，选择如何进行检索，</span></span><br><span class="line"><span class="comment">		同时将该函数类型定义为Student*，在找到所要找的对象时，返</span></span><br><span class="line"><span class="comment">		回其所在链表的位置P。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Student* <span class="title">Searchlist</span><span class="params">(<span class="built_in">string</span> name)</span></span>;</span><br><span class="line">	<span class="function">Student* <span class="title">Searchlist</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Deletedata</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Changelist</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	Linklist L;</span><br><span class="line">	L.Createlist();</span><br><span class="line">	L.Showlist();</span><br><span class="line">	L.Deletedata();</span><br><span class="line">	L.Showlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Linklist::Linklist() &#123;</span><br><span class="line">	n = <span class="number">0</span>;</span><br><span class="line">	head = <span class="keyword">new</span> Student;</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	rear = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Linklist::~Linklist() &#123;</span><br><span class="line">	<span class="keyword">delete</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Linklist::Createlist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> name, sex;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请按以下格式输入信息:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"学号，姓名，性别"</span> &lt;&lt;<span class="built_in">endl</span> ;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt; num &amp;&amp; num!=<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; name &gt;&gt; sex;</span><br><span class="line">		Attach(name, sex, num, &amp;rear);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;       <span class="comment">//返回有多少个节点（即有多少个人），暂时不需要</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该Attach函数是在链表尾部添加新节点，并且rear始终作为链表末节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Linklist::Attach</span><span class="params">(<span class="built_in">string</span> name, <span class="built_in">string</span> sex, <span class="keyword">int</span> num,Student**rear)</span> </span>&#123;</span><br><span class="line">	Student* P;</span><br><span class="line">	P = <span class="keyword">new</span> Student;</span><br><span class="line">	P-&gt;data.name = name;</span><br><span class="line">	P-&gt;data.sex = sex;</span><br><span class="line">	P-&gt;data.num = num;</span><br><span class="line">	P-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	(*rear)-&gt;next = P;</span><br><span class="line">	(*rear) = P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Linklist::Showlist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Student* P;</span><br><span class="line">	P = head;</span><br><span class="line">	<span class="keyword">while</span> (P-&gt;next) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名:"</span> &lt;&lt; P-&gt;next-&gt;data.name</span><br><span class="line">			 &lt;&lt; <span class="string">" 性别："</span> &lt;&lt; P-&gt;next-&gt;data.sex</span><br><span class="line">			 &lt;&lt; <span class="string">" 学号:"</span> &lt;&lt; P-&gt;next-&gt;data.num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		P = P-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student* <span class="title">Linklist::Searchlist</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">	Student* P;</span><br><span class="line">	P = head;</span><br><span class="line">		<span class="keyword">while</span> (P-&gt;next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (P-&gt;next-&gt;data.name == name) &#123;</span><br><span class="line">				<span class="keyword">return</span> P;</span><br><span class="line">			&#125;</span><br><span class="line">			P = P-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"未能找到相关信息"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student* <span class="title">Linklist::Searchlist</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	Student* P;</span><br><span class="line">	P = head;</span><br><span class="line">		<span class="keyword">while</span> (P-&gt;next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (P-&gt;next-&gt;data.num == num) &#123;</span><br><span class="line">				<span class="keyword">return</span> P;</span><br><span class="line">			&#125;</span><br><span class="line">			P = P-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"未能找到相关信息"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Linklist::Deletedata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> name,choice;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	Student* P=<span class="keyword">new</span> Student;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"你要以何种方式（num/name）删除信息："</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line">	<span class="keyword">if</span> (choice == <span class="string">"num"</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"你要删除哪个学号信息："</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">		P = Searchlist(num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (choice == <span class="string">"name"</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"你要删除哪个学生信息："</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">		P = Searchlist(name);</span><br><span class="line">	&#125;</span><br><span class="line">	Student* T=<span class="keyword">new</span> Student;</span><br><span class="line">	T = P-&gt;next-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> P-&gt;next;</span><br><span class="line">	P-&gt;next = T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Linklist::Changelist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> name, choice;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	Student* P = <span class="keyword">new</span> Student;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"你要以何种方式（num/name）修改信息："</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line">	<span class="keyword">if</span> (choice == <span class="string">"num"</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"你要修改哪个学号信息："</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">		P = Searchlist(num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (choice == <span class="string">"name"</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"你要修改哪个学生信息："</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">		P = Searchlist(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//结构中暂未添加保存成绩的数组，暂不具体做修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>2020.4.8：<strong>完成项</strong>：目前只完成链表的创建，链表指定节点的删除，链表节点信息的查找</p>
<p><strong>运用C++新学的知识</strong>：函数重载，类的定义，类的构造函数与析构函数。</p>
]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>C/C++语言</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》学习笔记（第一章）</title>
    <url>/2020/04/13/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h4 id="初识输入输出"><a href="#初识输入输出" class="headerlink" title="初识输入输出"></a>初识输入输出</h4><p>一. 输入输出流</p>
<ol>
<li><p><strong>istream</strong>: 输入流</p>
<p>1.1. cin: 标准输入</p>
</li>
<li><p>ostream: 输出流</p>
<p>2.1. cout: 标准输出</p>
<p>2.2. cerr: 输出警告和错误消息</p>
<p>2.3. clog: 输出程序运行时的一般性消息</p>
</li>
</ol>
<p>二. 输入输出运算符</p>
<p> 1.输出运算符:’ &lt;&lt; ‘:输出运算符接收两个运算对象，左侧必须是ostream的运算对象，右侧运算对象是要打印值</p>
<p> 2.操作符：std::endl :该效果是结束当前行，并保证输入流的所有输出都真正写入输出流。</p>
<p> 3.输入运算符: ‘ &gt;&gt; ‘:与输出运算符类似，该运算符左侧接受一个istream作为他的左侧运算对象，接受一个对象作为右侧运算对象</p>
<h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><p><strong><em>注意：在for语句中，如果我们在for语句外已经定义了一个变量如i,那么如果我们在for语句如此写：for(int i; ; ),那么for循环里的i是与循环外的i无关的，即可将for语句当成单独函数。</em></strong></p>
<ul>
<li>读取数量不定的输入数据：当我们使用istream对象作为作为条件是，如：while（cin &gt;&gt; value），它的效果是检测流的状态，只要输入正常，那么它就返回true。而遇到文件结束符（Windows里时Ctrl+Z,其它系统是Ctrl+D）或是遇到无效输入时（类型不匹配），istream才会返回false。</li>
</ul>
<h4 id="小结术语"><a href="#小结术语" class="headerlink" title="小结术语"></a>小结术语</h4><ol>
<li>命名空间（namespace）：可以将库定义的名字放在单一位置处。</li>
<li>std：标准库所使用的命名空间。</li>
<li>操纵符：在读写流时用来“操纵流”本身，如std::endl。</li>
<li>库类型：标准库定义的类型。</li>
<li>方法：成员函数的术名。</li>
<li>‘ . ‘运算符: 左侧为类类型对象，右侧时此对象的成员的名字。</li>
<li>‘ :: ‘运算符：作用域运算符</li>
</ol>
<h5 id="注：’-‘-运算符和’-‘-运算符的区别："><a href="#注：’-‘-运算符和’-‘-运算符的区别：" class="headerlink" title="注：’ . ‘ 运算符和’ :: ‘ 运算符的区别："></a>注：’ . ‘ 运算符和’ :: ‘ 运算符的区别：</h5><ol>
<li><p>名称和用法都不一样<br>1.1. “::” 操作符的用法有很多<br>（1）代表全局作用域  用法： ::name<br>（2）代表类作用域   用法:       class::name<br>（3）名字空间作用域  用法： namespace::name</p>
<p>1.2. “.” 操作符的主要作用是成员选择<br>（1）用法:     object.name</p>
</li>
</ol>
<p>   ​    <strong><em>ps:</em></strong></p>
<p>   （1）’ :: ‘    针对 <strong>类</strong>，表示作用域</p>
<p>   （2）’ . ‘     针对 <strong>对象</strong>，表示成员选择</p>
<p>   所以呢，类的静态成员（静态成员属于类），使用 ‘ :: ‘ 调用。</p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云CentOS8.0服务器宝塔安装失败，提示（setuptools installation failed）</title>
    <url>/2020/04/03/%E9%98%BF%E9%87%8C%E4%BA%91CentOS8-0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9D%E5%A1%94%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%EF%BC%8C%E6%8F%90%E7%A4%BA%EF%BC%88setuptools-installation-failed%EF%BC%89/</url>
    <content><![CDATA[<p>对于想要搭建一些个人网站的小伙伴们，苦于阿里云繁琐的设置界面无从下手，推荐一个简洁的控制面板：宝塔面板</p>
<p>推荐教程：[阿里云服务器安装宝塔面板图文教程]（<a href="https://developer.aliyun.com/ask/233242?spm=a2c6h.13524658）" target="_blank" rel="noopener">https://developer.aliyun.com/ask/233242?spm=a2c6h.13524658）</a></p>
<h1 id="我在安装宝塔服务器时，安装突然终止，然后给出"><a href="#我在安装宝塔服务器时，安装突然终止，然后给出" class="headerlink" title="我在安装宝塔服务器时，安装突然终止，然后给出"></a>我在安装宝塔服务器时，安装突然终止，然后给出</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setuptools installation failed</span><br></pre></td></tr></table></figure>
<h1 id="我想到的可能的解决办法："><a href="#我想到的可能的解决办法：" class="headerlink" title="我想到的可能的解决办法："></a>我想到的可能的解决办法：</h1><p>1.重新初始化我的云盘<br>2.重装我的云服务器系统</p>
<h3 id="办法一：重新初始化我的云盘"><a href="#办法一：重新初始化我的云盘" class="headerlink" title="办法一：重新初始化我的云盘"></a>办法一：重新初始化我的云盘</h3><p>1.关闭你的云服务器（一定要关，不然他不让你初始化）<br>2.点击本实例磁盘<br><img src="http://q86xw0tu1.bkt.clouddn.com/22548835-1b744f8ca09c6a6d.png" alt="进入初始化界面"><br>3.点击重新初始化，再安装一次宝塔面板即可<br><img src="http://q86xw0tu1.bkt.clouddn.com/22548835-43b129a4f77972ee.png" alt="云存储"></p>
<h3 id="办法二：重装我的云服务器系统"><a href="#办法二：重装我的云服务器系统" class="headerlink" title="办法二：重装我的云服务器系统"></a>办法二：重装我的云服务器系统</h3><p>我是先完成的重新初始化磁盘，发现安装还是失败了，于是我想到了重装系统，成功安装了宝塔面板。我所使用的时CentOS 8.0系统,也就是阿里云服务器上centos的最新版本，我认为也许是新版并不兼容宝塔面板。下面是解决办法：</p>
<p>1.如上：关闭云服务器（不再做演示）</p>
<p>2.在实例详细页面，往下翻找到配置信息，点击更多，点击更换操作系统进入更改页面<br><img src="http://q86xw0tu1.bkt.clouddn.com/22548835-a5d0f9b89f3c0a24.png" alt=""></p>
<p><img src="http://q86xw0tu1.bkt.clouddn.com/22548835-dff63787afe67517.png" alt="更改页面"><br>3.在这里我们还是选择centos系统，但是我们将版本选择为7.5 64位（当然也可以选择其他版本，我没试过），然后再重新设置一下密码，远程连接需要用到。</p>
<p>4.点击确认更换，然后系统重装完成，再安装宝塔面板（我成功安装了）。</p>
<h5 id="如果仍然没有解决问题，很抱歉耽搁你的时间了。。。。。。"><a href="#如果仍然没有解决问题，很抱歉耽搁你的时间了。。。。。。" class="headerlink" title="如果仍然没有解决问题，很抱歉耽搁你的时间了。。。。。。"></a>如果仍然没有解决问题，很抱歉耽搁你的时间了。。。。。。</h5>]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
        <tag>问题解决</tag>
      </tags>
  </entry>
</search>
