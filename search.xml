<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>路径压缩的quick-union算法</title>
    <url>/2020/05/05/Al%20%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E7%9A%84quick-union%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>​    输入的整数表示的可能是大型计算机网络中的计算机，整数对表示网络中的连接，这个算法可以判定我们是否需要在p和q之间架设新的连接才能通信。以下为最优算法算法——路径压缩的加权quick-union</p>
<p>​    其他算法还有quick-find，quick-union，加权quick-union算法。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">weight</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span>* id,*sz;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	weight(<span class="keyword">int</span> N) &#123;</span><br><span class="line">		count = N;			<span class="comment">//统计分量的数量，每连接一个就减一</span></span><br><span class="line">		id = <span class="keyword">new</span> <span class="keyword">int</span>[N];	<span class="comment">//父链接数组（连接它的上一级）</span></span><br><span class="line">		sz = <span class="keyword">new</span> <span class="keyword">int</span>[N];	<span class="comment">//统计节点的分量大小</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) id[i] = i;</span><br><span class="line">		<span class="comment">//将所有节点的分支初始化为1</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) sz[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断根节点是否相同</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">find</span>(p) == <span class="built_in">find</span>(q);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> box = s,sbox;</span><br><span class="line">		<span class="comment">//找到根节点</span></span><br><span class="line">		<span class="keyword">while</span> (s != id[s]) s = id[s];</span><br><span class="line">		<span class="comment">//以下循环就是路径压缩，将路径上的所有点连接到根节点处</span></span><br><span class="line">		<span class="keyword">while</span> (box != s) &#123;</span><br><span class="line">			sbox = id[box];</span><br><span class="line">			id[box] = s;</span><br><span class="line">			box = sbox;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//返回根节点</span></span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//返回根节点，若从无根节点，就返回自身</span></span><br><span class="line">		<span class="keyword">int</span> i = <span class="built_in">find</span>(p);</span><br><span class="line">		<span class="keyword">int</span> j = <span class="built_in">find</span>(q);</span><br><span class="line">		<span class="comment">//两节点相同就退出该函数</span></span><br><span class="line">		<span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line">		<span class="comment">//用以下语句将小树连接到大树</span></span><br><span class="line">		<span class="keyword">if</span> (sz[i] &lt; sz[j]) &#123; id[i] = j; sz[j] += sz[i]; &#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; id[j] = i; sz[i] += sz[j]; &#125;</span><br><span class="line">		count--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>压缩路径的加权quick-union算法是解决该问题的最优算法。</li>
</ul>
]]></content>
      <categories>
        <category>算法（第四版）</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>算法学习笔记（一）：牛顿迭代法（计算平方根）</title>
    <url>/2020/04/11/Al%20%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80)/</url>
    <content><![CDATA[<p>​    在算法（第四版）的13页里，我看到了一个的函数，它利用了牛顿迭代法来计算一个数的近似平方根，我通过查询资料理解了牛顿迭代法的实现过程。</p>
<a id="more"></a>
<p>​    这个方法所包含的知识：</p>
<p><em>1.导数的含义</em></p>
<p><em>2.极限的思维</em></p>
<p><em>3.函数的零点</em></p>
<h4 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h4><p>1.在求一个函数零点时，我们可以随意取一个点作为起始点(x0,f(x0)），并过该点做函数的切线,设切线的横截距为x1。在该点（x1,0）垂直于X轴引垂线，交函数于(x1,f(x1)),再对该点做与之前同样的操作，以此往复。如下图：</p>
<p><img src="http://www.morenmoren.com/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%9B%BE%E8%A7%A3.gif" alt="牛顿迭代法"></p>
<p>2.对所得到的数据进行处理,经过运算，第一条切线的横截距，多条切线横截距为:</p>
<script type="math/tex; mode=display">
x_1=x_0+f(x_0)/f'(x_0)\\
x_2=x_1+f(x_1)/f'(x_1)\\
.......\\
x_(n+1)=x_n+f(x_n)/f'(x_n)</script><h4 id="利用牛顿迭代法来求一个数的平方根"><a href="#利用牛顿迭代法来求一个数的平方根" class="headerlink" title="利用牛顿迭代法来求一个数的平方根"></a>利用牛顿迭代法来求一个数的平方根</h4><p>1.假设：</p>
<script type="math/tex; mode=display">
t=\sqrt[2]n\\
则设f(x)=x^2-n\\
可设x_0=n</script><p>2.利用代码实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> t;</span><br><span class="line">	t=n;</span><br><span class="line">	<span class="keyword">while</span>(t-n/t&lt;=<span class="number">1e-15</span>*t)</span><br><span class="line">        <span class="comment">//这里跳出循环的条件是你所要求的精度，即1-n/t^2要满足一定精度。</span></span><br><span class="line">		t=(t+n/t);</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法（第四版）</category>
      </categories>
      <tags>
        <tag>算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Java通信客户端</title>
    <url>/2020/04/22/Java%E9%80%9A%E4%BF%A1%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<p>​    <strong>在经过一段时间的学习，Java的一些基础知识基本上已经掌握，我十分急切的想要体验到Java的网络编程，但仍然实力不足，我偶然间看到B站上有一个教程，写着TCP通信客户端代码实现，在已经研究清楚的情况下，我在自己电脑里复现了一遍。</strong></p>
<a id="more"></a>
<h4 id="1-实现客户端的创建和数据传递："><a href="#1-实现客户端的创建和数据传递：" class="headerlink" title="1.实现客户端的创建和数据传递："></a>1.实现客户端的创建和数据传递：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  该文件的代码的目的是创建一个客户端</span></span><br><span class="line"><span class="comment">// 可以在Java文档里面查询到Socket的详细信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inetclient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个socket客户端，ip地址为127.0.0.1，端口号为8888</span></span><br><span class="line">        Socket socket=<span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">8888</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用getoutput()方法获取网络字节输出流对象</span></span><br><span class="line">        OutputStream os=socket.getOutputStream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//write方法接收的是byte类型的对象</span></span><br><span class="line">        <span class="comment">//向服务器写入数据,写入数据需要转化为byte类型，所以使用getbytes()</span></span><br><span class="line">        os.write(<span class="string">"你好服务器"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用getinput()获取网络字节输入流对象</span></span><br><span class="line">        InputStream is=socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出由服务器发送给该客户端的字符串</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-实现服务器的创建和数据传递："><a href="#2-实现服务器的创建和数据传递：" class="headerlink" title="2.实现服务器的创建和数据传递："></a>2.实现服务器的创建和数据传递：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用accept方法获取到客户端对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Netserver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建服务器，并指定端口号</span></span><br><span class="line">        ServerSocket server=<span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用accept方法链接一个客户端</span></span><br><span class="line">        Socket socket=server.accept();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用getoutput()方法获取网络字节输出流对象</span></span><br><span class="line">        InputStream is=socket.getInputStream();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将输入流写入到服务器</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bytes);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出由客户端发送给该服务器的字符串</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//给客户端回写一条数据</span></span><br><span class="line">        OutputStream os=socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">"你好客户端"</span>.getBytes());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//关闭服务器和客户端</span></span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="以下为实现结果："><a href="#以下为实现结果：" class="headerlink" title="以下为实现结果："></a>以下为实现结果：</h5><p>客户端实现结果：</p>
<p><img src="http://www.morenmoren.com/%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%93%E6%9E%9C.png" alt=""></p>
<p>服务器实现结果：</p>
<p><img src="http://www.morenmoren.com/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%8C%E6%88%90%E7%BB%93%E6%9E%9C.png" alt=""></p>
<ul>
<li><strong>之后我会尝试在我的阿里云服务器上传递数据</strong></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>TCP通信客户端</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to CSAPP 实验(一)：Datalab</title>
    <url>/2020/05/08/Introduction-to-CSAPP-%E5%AE%9E%E9%AA%8C-%E4%B8%80-%EF%BC%9ADatalab/</url>
    <content><![CDATA[<p>​        深入理解计算机系统实验：<strong>datalab</strong></p>
<a id="more"></a>
<ol>
<li>仅用~ &amp;实现异或：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//相当于实现书上bis(bic(x,y),bic(y,x))函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~(~(~x&amp;y)&amp;~(x&amp;~y));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>返回最小的二进制补码整数，即最高位为1，其它全为0：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//即符号位为1，其它全为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当x是最大的二进制补码时返回1，否则返回0：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two's complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个条件是想筛选出最大的二进制数与全1</span></span><br><span class="line"><span class="comment">//第二个条件则是将全一排除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (!(x+<span class="number">1</span>+x+<span class="number">1</span>))&amp;(!!(x+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果x所有偶数位为1,那么返回1，否则返回0：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第一步就是创造一个偶数位为1，奇数位为0的数，通过移位实现</span></span><br><span class="line"><span class="comment">//第二步，检测x的偶数位</span></span><br><span class="line"><span class="comment">//第三步，检测第二步是否有改变偶数位，若不改变，那么返回1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = <span class="number">0xaa</span> + (<span class="number">0xaa</span> &lt;&lt; <span class="number">8</span>) + (<span class="number">0xaa</span> &lt;&lt; <span class="number">16</span>) + (<span class="number">0xaa</span> &lt;&lt; <span class="number">24</span>);</span><br><span class="line">  <span class="keyword">int</span> y = k &amp; x;</span><br><span class="line">  <span class="keyword">return</span> !(y ^ k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求x的加法逆元：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果x在0x30到0x39之间(包含二者)，那么返回1，否则返回0：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运用了上一个函数的结论，我们无法用-，那么可以加上它的加法逆元</span></span><br><span class="line"><span class="comment">//通过判断2次相减后的正负（运用移位，只留下符号位）来看是否在该区间内</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !((x+~<span class="number">48</span>+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>)&amp;((x+~<span class="number">58</span>+<span class="number">1</span>)&gt;&gt;<span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现C语言里的：x ? y : z</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//思想：运用|，x非0，那么关于z的项为0. x为0，那么关于y的项为0</span></span><br><span class="line"><span class="comment">//我们可以通过！来直接区分0和非0</span></span><br><span class="line"><span class="comment">//如此便很容易将二者变为全1或者全0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((!x+~<span class="number">1</span>+<span class="number">1</span>)&amp;y)|((~!x+<span class="number">1</span>)&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果x&lt;=y，那么返回1，否则返回0：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里我发现如果二者的符号不同，加法逆元的时候会出问题，因为这可能导致溢出</span></span><br><span class="line"><span class="comment">//如此我们可以将2种情况分开，在一种情况发生时，另一种情况不起作用</span></span><br><span class="line"><span class="comment">//由此我们可以引进标识符sign.相同符号为0，否则为1.如此便简单许多</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> sign = !(x&gt;&gt;<span class="number">31</span>)^!(y&gt;&gt;<span class="number">31</span>);      </span><br><span class="line">   <span class="keyword">int</span> a = sign &amp; (x&gt;&gt;<span class="number">31</span>);   </span><br><span class="line">   <span class="keyword">int</span> b = !sign &amp; !((y+(~x+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>);  </span><br><span class="line">   <span class="keyword">return</span> a | b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运用位级运算符实现！：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们一般都首先实现特殊情况，再推广到一般</span></span><br><span class="line"><span class="comment">//显然，只有全0能够为实现在首位为0的情况下，~(~x+1)操作后首位变为1</span></span><br><span class="line"><span class="comment">//需要&amp;1,因为右移位补的是1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((~(~x+<span class="number">1</span>)&amp;~x)&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算构成x所需要的位数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two's complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//本题最难，运用了二分法的思想</span></span><br><span class="line"><span class="comment">//通过把负数取反，正数不变，我们需要找到第一个1所在的位数然后加1</span></span><br><span class="line"><span class="comment">//如此一共32位，我们就首先查16位处，之后8位处。。。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  x=x^(x&gt;&gt;<span class="number">31</span>);</span><br><span class="line">  <span class="keyword">int</span> b16=(!!(x&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">  x=x&gt;&gt;b16;</span><br><span class="line">  <span class="keyword">int</span> b8=(!!(x&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>;</span><br><span class="line">  x=x&gt;&gt;b8;</span><br><span class="line">  <span class="keyword">int</span> b4=(!!(x&gt;&gt;<span class="number">4</span>))&lt;&lt;<span class="number">2</span>;</span><br><span class="line">  x=x&gt;&gt;b4;</span><br><span class="line">  <span class="keyword">int</span> b2=(!!(x&gt;&gt;<span class="number">2</span>))&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  x=x&gt;&gt;b2;</span><br><span class="line">  <span class="keyword">int</span> b=(!!(x&gt;&gt;<span class="number">1</span>));</span><br><span class="line">  x=x&gt;&gt;b;</span><br><span class="line">  <span class="keyword">return</span> b+b16+b8+b4+b2+x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
</li>
</ol>
<p>以下位浮点数的使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//float</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> flag = uf &amp; <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="built_in">exp</span> = uf &gt;&gt; <span class="number">23</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> frac = uf &amp; <span class="number">0x7fffff</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xff</span>) <span class="comment">// NaN或者无穷大</span></span><br><span class="line">    flag = flag;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0</span>) <span class="comment">// 非规格化的</span></span><br><span class="line">    frac &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">0xfe</span>) &#123; <span class="comment">//接近无穷大</span></span><br><span class="line">    frac = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">exp</span> = <span class="number">0xff</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="built_in">exp</span> += <span class="number">1</span>; <span class="comment">// 规格化的</span></span><br><span class="line">  <span class="keyword">return</span> flag | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | frac;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> s_    = uf&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> exp_  = ((uf&amp;<span class="number">0x7f800000</span>)&gt;&gt;<span class="number">23</span>)<span class="number">-127</span>;</span><br><span class="line">  <span class="keyword">int</span> frac_ = (uf&amp;<span class="number">0x007fffff</span>)|<span class="number">0x00800000</span>;</span><br><span class="line">  <span class="keyword">if</span>(!(uf&amp;<span class="number">0x7fffffff</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(exp_ &gt; <span class="number">30</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="comment">//当E&gt;30时，即使frac=1,符号位也会被覆盖，所以不可以，返回0x800000。</span></span><br><span class="line">  <span class="keyword">if</span>(exp_ &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">    <span class="comment">//（1右移x位,x&gt;0，结果为0）则返回0。</span></span><br><span class="line">  <span class="keyword">if</span>(exp_ &gt; <span class="number">23</span>) frac_ &lt;&lt;= (exp_<span class="number">-23</span>);</span><br><span class="line">  <span class="keyword">else</span> frac_ &gt;&gt;= (<span class="number">23</span>-exp_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!((frac_&gt;&gt;<span class="number">31</span>)^s_)) <span class="keyword">return</span> frac_;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(frac_&gt;&gt;<span class="number">31</span>) <span class="keyword">return</span> <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> ~frac_+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">-149</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">-127</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (x + <span class="number">149</span>);</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">127</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span>;</span><br><span class="line">  <span class="keyword">return</span> (x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>《深入理解计算机系统》学习</category>
      </categories>
      <tags>
        <tag>《深入理解计算机系统》实验</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode 2.两数相加</title>
    <url>/2020/04/27/Leetcode%202.%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<p>​        给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p>
<a id="more"></a>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：</p>
<p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p>
<ol>
<li>Java的解法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode p = l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;		<span class="comment">//同样作为是否进位的判断</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> || q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//以下两个语句可以省去冗杂的讨论（讨论谁为空）</span></span><br><span class="line">        <span class="comment">//将链表的数据赋给参数，不必访问链表，不用担心空链表问题</span></span><br><span class="line">        <span class="keyword">int</span> x = (p != <span class="keyword">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = (q != <span class="keyword">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = carry + x + y;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//为链表连接上初始化好的节点</span></span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后如果存在进位，在这里得到解决</span></span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br></pre></td></tr></table></figure>
<ol>
<li>C++解法（这个自己想的，很复杂，可以改进）：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* l3=<span class="keyword">new</span> ListNode(<span class="number">0</span>),*rear;</span><br><span class="line">        rear=l3;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;	<span class="comment">//利用i作为是否进位的判断</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>&amp;&amp;l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val+l2-&gt;val+i&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                Attach(l1-&gt;val+l2-&gt;val<span class="number">-10</span>+i,&amp;rear);	<span class="comment">//连接节点</span></span><br><span class="line">                i=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; </span><br><span class="line">                Attach(l1-&gt;val+l2-&gt;val+i,&amp;rear);</span><br><span class="line">                i=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;next==<span class="literal">NULL</span>&amp;&amp;l2-&gt;next==<span class="literal">NULL</span>&amp;&amp;i==<span class="number">1</span>)&#123;</span><br><span class="line">                Attach(<span class="number">1</span>,&amp;rear);</span><br><span class="line">                i=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val+i&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                Attach(l1-&gt;val<span class="number">-10</span>+i,&amp;rear);</span><br><span class="line">                i=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; </span><br><span class="line">                Attach(l1-&gt;val+i,&amp;rear);</span><br><span class="line">                i=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;l1-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                Attach(<span class="number">1</span>,&amp;rear);</span><br><span class="line">                i=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l2-&gt;val+i&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                Attach(l2-&gt;val<span class="number">-10</span>+i,&amp;rear);</span><br><span class="line">                i=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; </span><br><span class="line">                Attach(l2-&gt;val+i,&amp;rear);</span><br><span class="line">                i=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;l2-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                Attach(<span class="number">1</span>,&amp;rear);</span><br><span class="line">                i=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        l3=l3-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> l3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="keyword">int</span> a,ListNode**Rear)</span></span>&#123;</span><br><span class="line">        ListNode* P=<span class="keyword">new</span> ListNode(a);</span><br><span class="line">        (*Rear)-&gt;next=P;</span><br><span class="line">        (*Rear)=P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Introduction to CSAPP 实验二：Bomblab</title>
    <url>/2020/05/11/Introduction-to-CSAPP-%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9ABomblab/</url>
    <content><![CDATA[<p>​        此次实验教会我基本的汇编语言知识，也教会了我使用gdb调试器做一些简单的调试，虽然过程很痛苦，但受益匪浅吧。</p>
<ul>
<li><p>我们只需要使用反汇编指令：objdump -d bomb即可得到汇编代码。</p>
<a id="more"></a>
</li>
</ul>
<h5 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase_1"></a>Phase_1</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400ee4:	be 00 24 40 00       	mov    $0x402400,%esi</span><br><span class="line">  400ee9:	e8 4a 04 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:	85 c0                	test   %eax,%eax</span><br><span class="line">  400ef0:	74 05                	je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:	e8 43 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  400efb:	c3                   	retq</span><br><span class="line"></span><br><span class="line">  000000000040131b &lt;string_length&gt;:</span><br><span class="line">  40131b:	80 3f 00             	cmpb   $0x0,(%rdi)      </span><br><span class="line">  &#x2F;&#x2F;判断是否是空字符串</span><br><span class="line">  40131e:	74 12                	je     401332 &lt;string_length+0x17&gt;</span><br><span class="line">  401320:	48 89 fa             	mov    %rdi,%rdx        </span><br><span class="line">  &#x2F;&#x2F;将地址赋给%rdx</span><br><span class="line">  401323:	48 83 c2 01          	add    $0x1,%rdx        </span><br><span class="line">  401327:	89 d0                	mov    %edx,%eax        </span><br><span class="line">  &#x2F;&#x2F;将地址给参数存储器，这个存储器的值将作为返回值</span><br><span class="line">  401329:	29 f8                	sub    %edi,%eax        </span><br><span class="line">  &#x2F;&#x2F;计算前后2个地址的差，得到的就是字符串的长度</span><br><span class="line">  40132b:	80 3a 00             	cmpb   $0x0,(%rdx)      </span><br><span class="line">  &#x2F;&#x2F;判断是否是字符串的最后一个元素</span><br><span class="line">  40132e:	75 f3                	jne    401323 &lt;string_length+0x8&gt;</span><br><span class="line">  401330:	f3 c3                	repz retq </span><br><span class="line">  401332:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401337:	c3                   	retq   </span><br><span class="line"></span><br><span class="line">0000000000401338 &lt;strings_not_equal&gt;:</span><br><span class="line">  401338:	41 54                	push   %r12</span><br><span class="line">  40133a:	55                   	push   %rbp</span><br><span class="line">  40133b:	53                   	push   %rbx</span><br><span class="line">  40133c:	48 89 fb             	mov    %rdi,%rbx        </span><br><span class="line">  40133f:	48 89 f5             	mov    %rsi,%rbp        &#x2F;&#x2F;这两个参数分别是2个字符串</span><br><span class="line">  401342:	e8 d4 ff ff ff       	callq  40131b &lt;string_length&gt;       &#x2F;&#x2F;将rdi作为第一个参数传递到string_length</span><br><span class="line">  401347:	41 89 c4             	mov    %eax,%r12d       &#x2F;&#x2F;将字符串长度赋给%r12d</span><br><span class="line">  40134a:	48 89 ef             	mov    %rbp,%rdi</span><br><span class="line">  40134d:	e8 c9 ff ff ff       	callq  40131b &lt;string_length&gt;</span><br><span class="line">  401352:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">  401357:	41 39 c4             	cmp    %eax,%r12d       </span><br><span class="line">  &#x2F;&#x2F;判断输入字符串与正确字符串长度是否相等</span><br><span class="line">  40135a:	75 3f                jne  	40139b&lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40135c:	0f b6 03             	movzbl (%rbx),%eax      </span><br><span class="line">  &#x2F;&#x2F;将字符串第一个元素的内容赋给存储器</span><br><span class="line">  40135f:	84 c0                	test   %al,%al      </span><br><span class="line">  &#x2F;&#x2F;判断字符串内容是否为0</span><br><span class="line">  401361:	74 25                je     401388 &lt;strings_not_equal+0x50&gt;</span><br><span class="line">  401363:	3a 45 00             	cmp    0x0(%rbp),%al    </span><br><span class="line">  &#x2F;&#x2F;如果2字符串内容相等</span><br><span class="line">  401366:	74 0a                	je     401372 &lt;strings_not_equal+0x3a&gt;</span><br><span class="line">  401368:	eb 25                	jmp    40138f &lt;strings_not_equal+0x57&gt;</span><br><span class="line">  40136a:	3a 45 00             	cmp    0x0(%rbp),%al</span><br><span class="line">  40136d:	0f 1f 00             	nopl   (%rax)</span><br><span class="line">  401370:	75 24                	jne    401396 &lt;strings_not_equal+0x5e&gt;</span><br><span class="line">  401372:	48 83 c3 01          	add    $0x1,%rbx        </span><br><span class="line">  &#x2F;&#x2F;2字符串第一个元素相等的话，就移到下一个元素</span><br><span class="line">  401376:	48 83 c5 01          	add    $0x1,%rbp</span><br><span class="line">  40137a:	0f b6 03             	movzbl (%rbx),%eax</span><br><span class="line">  40137d:	84 c0                	test   %al,%al</span><br><span class="line">  40137f:	75 e9                	jne    40136a &lt;strings_not_equal+0x32&gt;      </span><br><span class="line">  401381:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">  401386:	eb 13                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401388:	ba 00 00 00 00       	mov    $0x0,%edx</span><br><span class="line">  40138d:	eb 0c                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  40138f:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">  401394:	eb 05                	jmp    40139b &lt;strings_not_equal+0x63&gt;</span><br><span class="line">  401396:	ba 01 00 00 00       	mov    $0x1,%edx</span><br><span class="line">  40139b:	89 d0                	mov    %edx,%eax</span><br><span class="line">  40139d:	5b                   	pop    %rbx</span><br><span class="line">  40139e:	5d                   	pop    %rbp</span><br><span class="line">  40139f:	41 5c                	pop    %r12</span><br><span class="line">  4013a1:	c3                   	retq </span><br><span class="line">  </span><br><span class="line">  Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure>
<ul>
<li>本题根据分析，容易知道当调用strings_not_equal函数时，该函数目的是判断我们输入的字符串是否是正确字符串，那么我们只要找到正确字符串的地址就能写出正确答案，该地址为：0x402400。通过：x/s 0x402400即可查看字符串。答案在代码末尾</li>
</ul>
<h5 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase_2"></a>Phase_2</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:	55                   	push   %rbp     </span><br><span class="line">  400efd:	53                   	push   %rbx</span><br><span class="line">  400efe:	48 83 ec 28          	sub    $0x28,%rsp    &#x2F;&#x2F;栈顶地址变更</span><br><span class="line">  400f02:	48 89 e6             	mov    %rsp,%rsi        </span><br><span class="line">  &#x2F;&#x2F;将栈顶地址交给传入参数</span><br><span class="line">  400f05:	e8 52 05 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)      </span><br><span class="line">  &#x2F;&#x2F;栈顶元素为1，也就是第一个元素为1</span><br><span class="line">  400f0e:	74 20                	je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:	e8 25 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:	eb 19                	jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax</span><br><span class="line">  400f1a:	01 c0                	add    %eax,%eax        </span><br><span class="line">  &#x2F;&#x2F;前一个数乘以2</span><br><span class="line">  400f1c:	39 03                	cmp    %eax,(%rbx)      </span><br><span class="line">  &#x2F;&#x2F;判断后一个数是否是前一个数的2倍</span><br><span class="line">  400f1e:	74 05                	je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:	e8 15 05 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:	48 83 c3 04          	add    $0x4,%rbx        </span><br><span class="line">  &#x2F;&#x2F;指向下一个参数</span><br><span class="line">  400f29:	48 39 eb             	cmp    %rbp,%rbx</span><br><span class="line">  400f2c:	75 e9                	jne    400f17 &lt;phase_2+0x1b&gt;        &#x2F;&#x2F;还没循环到最后就继续循环</span><br><span class="line">  400f2e:	eb 0c                	jmp    400f3c &lt;phase_2+0x40&gt;        &#x2F;&#x2F;等于指向尾元素的下一个元素就退出循环</span><br><span class="line">  400f30:	48 8d 5c 24 04       	lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:	48 8d 6c 24 18       	lea    0x18(%rsp),%rbp      </span><br><span class="line">  &#x2F;&#x2F;指向尾元素的下一个元素，相当于充当结束条件</span><br><span class="line">  400f3a:	eb db                	jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:	48 83 c4 28          	add    $0x28,%rsp</span><br><span class="line">  400f40:	5b                   	pop    %rbx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:	48 83 ec 18          	sub    $0x18,%rsp       </span><br><span class="line">  &#x2F;&#x2F;栈顶地址变更</span><br><span class="line">  401460:	48 89 f2             	mov    %rsi,%rdx        </span><br><span class="line">  &#x2F;&#x2F;将传入的原来的栈顶地址交给第一个参数</span><br><span class="line">  401463:	48 8d 4e 04          	lea    0x4(%rsi),%rcx   </span><br><span class="line">  401467:	48 8d 46 14          	lea    0x14(%rsi),%rax</span><br><span class="line">  40146b:	48 89 44 24 08       	mov    %rax,0x8(%rsp)</span><br><span class="line">  401470:	48 8d 46 10          	lea    0x10(%rsi),%rax</span><br><span class="line">  401474:	48 89 04 24          	mov    %rax,(%rsp)</span><br><span class="line">  401478:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9</span><br><span class="line">  40147c:	4c 8d 46 08          	lea    0x8(%rsi),%r8</span><br><span class="line">  401480:	be c3 25 40 00       	mov    $0x4025c3,%esi</span><br><span class="line">  401485:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  40148a:	e8 61 f7 ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:	83 f8 05             	cmp    $0x5,%eax</span><br><span class="line">  401492:	7f 05                jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:	e8 a1 ff ff ff       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  40149d:	c3                   	retq</span><br><span class="line">  </span><br><span class="line">	1 2 4 8 16 32</span><br></pre></td></tr></table></figure>
<ul>
<li>这里使用到了循环，分析可知，输入的后一个数是前一个数的2倍，又可以得出第一个输入的数字为1，那么很容易就得到答案。</li>
</ul>
<h5 id="Phase-3"><a href="#Phase-3" class="headerlink" title="Phase_3"></a>Phase_3</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  400f47:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:	be cf 25 40 00       	mov    $0x4025cf,%esi</span><br><span class="line">  400f56:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400f5b:	e8 90 fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:	83 f8 01             	cmp    $0x1,%eax</span><br><span class="line">  400f63:	7f 05                	jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:	e8 d0 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:	77 3c                	ja     400fad &lt;phase_3+0x6a&gt;         &#x2F;&#x2F;输入的某个数&lt;&#x3D;7</span><br><span class="line">  400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:	ff 24 c5 70 24 40 00 	jmpq   *0x402470(,%rax,8)   </span><br><span class="line">  &#x2F;&#x2F;根据第1个元素的值跳转</span><br><span class="line">  400f7c:	b8 cf 00 00 00       	mov    $0xcf,%eax       </span><br><span class="line">  &#x2F;&#x2F;当第1个元素为0</span><br><span class="line">  400f81:	eb 3b                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:	b8 c3 02 00 00       	mov    $0x2c3,%eax      </span><br><span class="line">  &#x2F;&#x2F;当第1个元素为2</span><br><span class="line">  400f88:	eb 34                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:	b8 00 01 00 00       	mov    $0x100,%eax      </span><br><span class="line">  &#x2F;&#x2F;当第1个元素为3</span><br><span class="line">  400f8f:	eb 2d                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:	b8 85 01 00 00       	mov    $0x185,%eax      </span><br><span class="line">  &#x2F;&#x2F;当第1个元素为4</span><br><span class="line">  400f96:	eb 26                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:	b8 ce 00 00 00       	mov    $0xce,%eax       </span><br><span class="line">  &#x2F;&#x2F;当第1个元素为5</span><br><span class="line">  400f9d:	eb 1f                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:	b8 aa 02 00 00       	mov    $0x2aa,%eax      </span><br><span class="line">  &#x2F;&#x2F;当第1个元素为6</span><br><span class="line">  400fa4:	eb 18                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:	b8 47 01 00 00       	mov    $0x147,%eax      </span><br><span class="line">  &#x2F;&#x2F;当第1个元素为7</span><br><span class="line">  400fab:	eb 11                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:	e8 88 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400fb7:	eb 05                	jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:	b8 37 01 00 00       	mov    $0x137,%eax  </span><br><span class="line">  &#x2F;&#x2F;当第二个元素为1</span><br><span class="line">  400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax       </span><br><span class="line">  &#x2F;&#x2F;第一个参数必须要等于0xcf</span><br><span class="line">  400fc2:	74 05                	je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:	e8 71 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  400fcd:	c3                   	retq</span><br><span class="line">  </span><br><span class="line">答案有8个：0 0xcf	  1  0x137       2  0x2c3     3 0x100   4  0x185             5 0xce       6  0x2aa       7  0x147</span><br></pre></td></tr></table></figure>
<ul>
<li>此题会根据你第一个数输入的不同而导致有多种答案，在代码中以标注，相当于switch。</li>
</ul>
<h5 id="Phase-4"><a href="#Phase-4" class="headerlink" title="Phase_4"></a>Phase_4</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:	48 83 ec 18          	sub    $0x18,%rsp</span><br><span class="line">  401010:	48 8d 4c 24 0c       	lea    0xc(%rsp),%rcx</span><br><span class="line">  401015:	48 8d 54 24 08       	lea    0x8(%rsp),%rdx</span><br><span class="line">  40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi       </span><br><span class="line">  &#x2F;&#x2F;根据gdb，输入为2个整数</span><br><span class="line">  40101f:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  401024:	e8 c7 fb ff ff       	callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  40102c:	75 07                	jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)</span><br><span class="line">  401033:	76 05                	jbe    40103a &lt;phase_4+0x2e&gt;    </span><br><span class="line">  &#x2F;&#x2F;第一个输入的整数要小于等于14</span><br><span class="line">  401035:	e8 00 04 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:	ba 0e 00 00 00       	mov    $0xe,%edx</span><br><span class="line">  40103f:	be 00 00 00 00       	mov    $0x0,%esi            </span><br><span class="line">  401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi       </span><br><span class="line">  &#x2F;&#x2F;以第一个输入的整数为传入函数的第一个参数</span><br><span class="line">  401048:	e8 81 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  40104d:	85 c0                	test   %eax,%eax        </span><br><span class="line">  40104f:	75 07                	jne    401058 &lt;phase_4+0x4c&gt;       </span><br><span class="line">  401051:	83 7c 24 0c 00          cmpl   $0x0,0xc(%rsp)           </span><br><span class="line">  &#x2F;&#x2F;第二个输入为0</span><br><span class="line">  401056:	74 05                	je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:	e8 dd 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:	48 83 c4 18          	add    $0x18,%rsp</span><br><span class="line">  401061:	c3                   	retq </span><br><span class="line">  </span><br><span class="line">  0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:	48 83 ec 08          	sub    $0x8,%rsp</span><br><span class="line">  400fd2:	89 d0                	mov    %edx,%eax    </span><br><span class="line">  &#x2F;&#x2F;c,最开始进入函数时，%edx&#x3D;0xe&#x3D;%eax</span><br><span class="line">  400fd4:	29 f0                	sub    %esi,%eax    &#x2F;&#x2F;c&#x3D;c-b</span><br><span class="line">  400fd6:	89 c1                	mov    %eax,%ecx    </span><br><span class="line">  400fd8:	c1 e9 1f             	shr    $0x1f,%ecx       </span><br><span class="line">  &#x2F;&#x2F;逻辑右移</span><br><span class="line">  400fdb:	01 c8                	add    %ecx,%eax</span><br><span class="line">  400fdd:	d1 f8                	sar    %eax         </span><br><span class="line">  &#x2F;&#x2F;算数右移（此处是一个缩写，实际上是右移一位）即(c-b)&#x2F;2</span><br><span class="line">  400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx         &#x2F;&#x2F;(c+b)&#x2F;2</span><br><span class="line">  400fe2:	39 f9                	cmp    %edi,%ecx</span><br><span class="line">  400fe4:	7e 0c                	jle    400ff2 &lt;func4+0x24&gt;       </span><br><span class="line">  400fe6:	8d 51 ff             	lea    -0x1(%rcx),%edx              &#x2F;&#x2F;(c+b)&#x2F;2-1 </span><br><span class="line">  400fe9:	e8 e0 ff ff ff       	callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:	01 c0                	add    %eax,%eax</span><br><span class="line">  400ff0:	eb 15                	jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  400ff7:	39 f9                	cmp    %edi,%ecx         </span><br><span class="line">  &#x2F;&#x2F;参数与输入的第一个整数比较</span><br><span class="line">  400ff9:	7d 0c                	jge    401007 &lt;func4+0x39&gt;       </span><br><span class="line">  400ffb:	8d 71 01             	lea    0x1(%rcx),%esi</span><br><span class="line">  400ffe:	e8 cb ff ff ff       	callq  400fce &lt;func4&gt;       &#x2F;&#x2F;递归</span><br><span class="line">  401003:	8d 44 00 01          	lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:	48 83 c4 08          	add    $0x8,%rsp</span><br><span class="line">  40100b:	c3                   	retq</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> <span class="built_in">step</span>, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* edi = target; esi = step; edx = limit */</span></span><br><span class="line">	<span class="keyword">int</span> temp = (limit - <span class="built_in">step</span>) * <span class="number">0.5</span>;</span><br><span class="line">	<span class="keyword">int</span> mid = temp + <span class="built_in">step</span>;</span><br><span class="line">	<span class="keyword">if</span> (mid &gt; target) &#123;</span><br><span class="line">		limit = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> ret1 = func4(target, <span class="built_in">step</span>, limit);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * ret1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (mid &gt;= target) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">step</span> = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">int</span> ret2 = func4(target, <span class="built_in">step</span>, limit);</span><br><span class="line">			<span class="keyword">return</span> (<span class="number">2</span> * ret2 + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; func4(i, <span class="number">0</span>, <span class="number">14</span>) || i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">14</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!func4(i, <span class="number">0</span>, <span class="number">14</span>)) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">结果为<span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line">所以答案有<span class="number">4</span>个： <span class="number">0</span> <span class="number">0</span>   <span class="number">1</span> <span class="number">0</span>   <span class="number">3</span> <span class="number">0</span>   <span class="number">7</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>此题的关键在于func4函数的理解，如果能够将其翻译为高级语言，那么破译起来就会变得相当简单。</li>
</ul>
<h5 id="Phase-5"><a href="#Phase-5" class="headerlink" title="Phase_5"></a>Phase_5</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:	53                   	push   %rbx</span><br><span class="line">  401063:	48 83 ec 20          	sub    $0x20,%rsp</span><br><span class="line">  401067:	48 89 fb             	mov    %rdi,%rbx</span><br><span class="line">  40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax        &#x2F;&#x2F;金丝雀</span><br><span class="line">  401071:	00 00 </span><br><span class="line">  401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:	31 c0                	xor    %eax,%eax</span><br><span class="line">  40107a:	e8 9c 02 00 00       	callq  40131b &lt;string_length&gt;       </span><br><span class="line">  40107f:	83 f8 06             	cmp    $0x6,%eax    </span><br><span class="line">  &#x2F;&#x2F;此时%eax等于6，即输入的长度为6</span><br><span class="line">  401082:	74 4e                	je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:	e8 b1 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:	eb 47                	jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx       </span><br><span class="line">  40108f:	88 0c 24             	mov    %cl,(%rsp)</span><br><span class="line">  401092:	48 8b 14 24          	mov    (%rsp),%rdx</span><br><span class="line">  401096:	83 e2 0f             	and    $0xf,%edx</span><br><span class="line">  401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">  4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)    </span><br><span class="line">  &#x2F;&#x2F;取我们字符串里每个字符的低4位，即对照Ascii码表字母的低四位，要想取到</span><br><span class="line">  flyers，即对应ionefg</span><br><span class="line">  4010a4:	48 83 c0 01          	add    $0x1,%rax</span><br><span class="line">  4010a8:	48 83 f8 06          	cmp    $0x6,%rax        </span><br><span class="line">  &#x2F;&#x2F;确定处理完6个字符，未处理完就再次循环</span><br><span class="line">  4010ac:	75 dd                	jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi       </span><br><span class="line">  &#x2F;&#x2F;要求输入的字符串在该地址，为flyers</span><br><span class="line">  4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi      </span><br><span class="line">  &#x2F;&#x2F;此时进入比较序列的并不是我们输入的字符，所以输入flyers是错误的</span><br><span class="line">  4010bd:	e8 76 02 00 00       	callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  4010c2:	85 c0                	test   %eax,%eax</span><br><span class="line">  4010c4:	74 13                	je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:	e8 6f 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:	eb 07                	jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:	b8 00 00 00 00       	mov    $0x0,%eax</span><br><span class="line">  4010d7:	eb b2                	jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:	00 00 </span><br><span class="line">  4010e7:	74 05                	je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:	e8 42 fa ff ff       callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:	48 83 c4 20          	add    $0x20,%rsp</span><br><span class="line">  4010f2:	5b                   	pop    %rbx</span><br><span class="line">  4010f3:	c3                   	retq </span><br><span class="line">  </span><br><span class="line">    ionefg</span><br></pre></td></tr></table></figure>
<ul>
<li>此时同样想到找字符串的地址，我们的确找到了0x40245e，看到了flyers，但是这并不是我们的答案，我们输入的字符串在中间会被函数更改，最终做对比的并不是我们最初输入的字符串。在函数中间，我们同样看见一个地址0x4024b0，它给的一长串字符就是我们的字母表。</li>
<li>在函数里，输入字符串里的每一个字符会被取低四位来在这一长串字符里面找对应字母，所以找Ascii码表。我们只需要找到对应字母，看他在这一长串字符前面有几个字符，然后转化为4位2进制，查表的到的字符就是我们的答案。</li>
</ul>
<h5 id="Phase-6"><a href="#Phase-6" class="headerlink" title="Phase_6"></a>Phase_6</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:	41 56                	push   %r14</span><br><span class="line">  4010f6:	41 55                	push   %r13</span><br><span class="line">  4010f8:	41 54                	push   %r12</span><br><span class="line">  4010fa:	55                   	push   %rbp</span><br><span class="line">  4010fb:	53                   	push   %rbx</span><br><span class="line">  4010fc:	48 83 ec 50          	sub    $0x50,%rsp</span><br><span class="line">  401100:	49 89 e5             	mov    %rsp,%r13</span><br><span class="line">  401103:	48 89 e6             	mov    %rsp,%rsi</span><br><span class="line">  401106:	e8 51 03 00 00       	callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  40110b:	49 89 e6             	mov    %rsp,%r14</span><br><span class="line">  40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d</span><br><span class="line">  401114:	4c 89 ed             	mov    %r13,%rbp</span><br><span class="line">  401117:	41 8b 45 00          	mov    0x0(%r13),%eax</span><br><span class="line">  40111b:	83 e8 01             	sub    $0x1,%eax    </span><br><span class="line">  40111e:	83 f8 05             	cmp    $0x5,%eax        </span><br><span class="line">  &#x2F;&#x2F;所有输入&lt;&#x3D;6</span><br><span class="line">  401121:	76 05                	jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:	e8 12 03 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401128:	41 83 c4 01          	add    $0x1,%r12d</span><br><span class="line">  40112c:	41 83 fc 06          	cmp    $0x6,%r12d</span><br><span class="line">  401130:	74 21                	je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">  401132:	44 89 e3             	mov    %r12d,%ebx</span><br><span class="line">  401135:	48 63 c3             	movslq %ebx,%rax</span><br><span class="line">  401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax   </span><br><span class="line">  40113b:	39 45 00             	cmp    %eax,0x0(%rbp)       </span><br><span class="line">  40113e:	75 05                	jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">  401140:	e8 f5 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:	83 c3 01             	add    $0x1,%ebx        </span><br><span class="line">  401148:	83 fb 05             	cmp    $0x5,%ebx</span><br><span class="line">  40114b:	7e e8                	jle    401135 &lt;phase_6+0x41&gt;        &#x2F;&#x2F;反复循环说明第一个元素与其他元素均不相等</span><br><span class="line">  40114d:	49 83 c5 04          	add    $0x4,%r13        </span><br><span class="line">  401151:	eb c1                	jmp    401114 &lt;phase_6+0x20&gt;        &#x2F;&#x2F;当移到下一个元素时，再次进入循环，说明6个元素均不相等，且所有输入小于等于6</span><br><span class="line">  401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi</span><br><span class="line">  401158:	4c 89 f0             	mov    %r14,%rax</span><br><span class="line">  40115b:	b9 07 00 00 00       	mov    $0x7,%ecx</span><br><span class="line">  401160:	89 ca                	mov    %ecx,%edx</span><br><span class="line">  401162:	2b 10                	sub    (%rax),%edx      &#x2F;&#x2F;c&#x3D;7-a1</span><br><span class="line">  401164:	89 10                	mov    %edx,(%rax)      &#x2F;&#x2F;a1&#x3D;c</span><br><span class="line">  401166:	48 83 c0 04          	add    $0x4,%rax</span><br><span class="line">  40116a:	48 39 f0             	cmp    %rsi,%rax</span><br><span class="line">  40116d:	75 f1                	jne    401160 &lt;phase_6+0x6c&gt;        &#x2F;&#x2F;每个元素等于自身减7</span><br><span class="line">  40116f:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401174:	eb 21                	jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">  401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx</span><br><span class="line">  40117a:	83 c0 01             	add    $0x1,%eax</span><br><span class="line">  40117d:	39 c8                	cmp    %ecx,%eax                </span><br><span class="line">  40117f:	75 f5                	jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  401181:	eb 05                	jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">  401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">  40118d:	48 83 c6 04          	add    $0x4,%rsi</span><br><span class="line">  401191:	48 83 fe 18          	cmp    $0x18,%rsi</span><br><span class="line">  401195:	74 14                	je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">  401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx       </span><br><span class="line">  &#x2F;&#x2F;指向下一个元素</span><br><span class="line">  40119a:	83 f9 01             	cmp    $0x1,%ecx        </span><br><span class="line">  &#x2F;&#x2F;此时判断每个元素是否都小于等于1</span><br><span class="line">  40119d:	7e e4                	jle    401183 &lt;phase_6+0x8f&gt;    </span><br><span class="line">  &#x2F;&#x2F;此处循环作为某个参数是否小于等于1的标志</span><br><span class="line">  40119f:	b8 01 00 00 00       	mov    $0x1,%eax</span><br><span class="line">  4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx</span><br><span class="line">  4011a9:	eb cb                	jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx      </span><br><span class="line">  4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax      </span><br><span class="line">  4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:	48 89 d9             	mov    %rbx,%rcx</span><br><span class="line">  4011bd:	48 8b 10             	mov    (%rax),%rdx</span><br><span class="line">  4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)       </span><br><span class="line">  4011c4:	48 83 c0 08          	add    $0x8,%rax            </span><br><span class="line">  4011c8:	48 39 f0             	cmp    %rsi,%rax            </span><br><span class="line">  4011cb:	74 05                	je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:	48 89 d1             	mov    %rdx,%rcx       </span><br><span class="line">  4011d0:	eb eb                	jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)</span><br><span class="line">  4011d9:	00 </span><br><span class="line">  4011da:	bd 05 00 00 00       	mov    $0x5,%ebp</span><br><span class="line">  4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax</span><br><span class="line">  4011e3:	8b 00                	mov    (%rax),%eax</span><br><span class="line">  4011e5:	39 03                	cmp    %eax,(%rbx)  </span><br><span class="line">  4011e7:	7d 05                	jge    4011ee &lt;phase_6+0xfa&gt;        &#x2F;&#x2F;判断序列是否是降序</span><br><span class="line">  4011e9:	e8 4c 02 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx</span><br><span class="line">  4011f2:	83 ed 01             	sub    $0x1,%ebp</span><br><span class="line">  4011f5:	75 e8                	jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  4011f7:	48 83 c4 50          	add    $0x50,%rsp</span><br><span class="line">  4011fb:	5b                   	pop    %rbx</span><br><span class="line">  4011fc:	5d                   	pop    %rbp</span><br><span class="line">  4011fd:	41 5c                	pop    %r12</span><br><span class="line">  4011ff:	41 5d                	pop    %r13</span><br><span class="line">  401201:	41 5e                	pop    %r14</span><br><span class="line">  401203:	c3                   	retq </span><br><span class="line">  </span><br><span class="line">  4 3 2 1 6 5</span><br></pre></td></tr></table></figure>
<ul>
<li>本题运用到了链表，而它会判断我们输入的数字对应的节点的索引是否是降序排列，如此我们就需要查找链表下面所有节点来找到索引，安装降序排列输入即可。</li>
<li>输入 <code>x/30w 0x6032d0</code> 得到节点情况。</li>
</ul>
<p><strong>至此，6个Phase已全部解决，第六个Phase难道最大，运用了链表。</strong></p>
]]></content>
      <categories>
        <category>《深入理解计算机系统》学习</category>
      </categories>
      <tags>
        <tag>《深入理解计算机系统》实验</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++ Primer》学习笔记（第一部分第一章）</title>
    <url>/2020/04/13/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h4 id="初识输入输出"><a href="#初识输入输出" class="headerlink" title="初识输入输出"></a>初识输入输出</h4><a id="more"></a>
<p>一. 输入输出流</p>
<ol>
<li><p><strong>istream</strong>: 输入流</p>
<p>1.1. cin: 标准输入</p>
</li>
<li><p>ostream: 输出流</p>
<p>2.1. cout: 标准输出</p>
<p>2.2. cerr: 输出警告和错误消息</p>
<p>2.3. clog: 输出程序运行时的一般性消息</p>
</li>
</ol>
<p>二. 输入输出运算符</p>
<p> 1.输出运算符:’ &lt;&lt; ‘:输出运算符接收两个运算对象，左侧必须是ostream的运算对象，右侧运算对象是要打印值</p>
<p> 2.操作符：std::endl :该效果是结束当前行，并保证输入流的所有输出都真正写入输出流。</p>
<p> 3.输入运算符: ‘ &gt;&gt; ‘:与输出运算符类似，该运算符左侧接受一个istream作为他的左侧运算对象，接受一个对象作为右侧运算对象</p>
<h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><p><strong><em>注意：在for语句中，如果我们在for语句外已经定义了一个变量如i,那么如果我们在for语句如此写：for(int i; ; ),那么for循环里的i是与循环外的i无关的，即可将for语句当成单独函数。</em></strong></p>
<ul>
<li>读取数量不定的输入数据：当我们使用istream对象作为作为条件是，如：while（cin &gt;&gt; value），它的效果是检测流的状态，只要输入正常，那么它就返回true。而遇到文件结束符（Windows里时Ctrl+Z,其它系统是Ctrl+D）或是遇到无效输入时（类型不匹配），istream才会返回false。</li>
</ul>
<h4 id="小结术语"><a href="#小结术语" class="headerlink" title="小结术语"></a>小结术语</h4><ol>
<li>命名空间（namespace）：可以将库定义的名字放在单一位置处。</li>
<li>std：标准库所使用的命名空间。</li>
<li>操纵符：在读写流时用来“操纵流”本身，如std::endl。</li>
<li>库类型：标准库定义的类型。</li>
<li>方法：成员函数的术名。</li>
<li>‘ . ‘运算符: 左侧为类类型对象，右侧时此对象的成员的名字。</li>
<li>‘ :: ‘运算符：作用域运算符</li>
</ol>
<h5 id="注：’-‘-运算符和’-‘-运算符的区别："><a href="#注：’-‘-运算符和’-‘-运算符的区别：" class="headerlink" title="注：’ . ‘ 运算符和’ :: ‘ 运算符的区别："></a>注：’ . ‘ 运算符和’ :: ‘ 运算符的区别：</h5><ol>
<li><p>名称和用法都不一样<br>1.1. “::” 操作符的用法有很多<br>（1）代表全局作用域  用法： ::name<br>（2）代表类作用域   用法:       class::name<br>（3）名字空间作用域  用法： namespace::name</p>
<p>1.2. “.” 操作符的主要作用是成员选择<br>（1）用法:     object.name</p>
</li>
</ol>
<p>   ​    <strong><em>ps:</em></strong></p>
<p>   （1）’ :: ‘    针对 <strong>类</strong>，表示作用域</p>
<p>   （2）’ . ‘     针对 <strong>对象</strong>，表示成员选择</p>
<p>   所以呢，类的静态成员（静态成员属于类），使用 ‘ :: ‘ 调用。</p>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++Primer》学习笔记（第一部分第七章）</title>
    <url>/2020/05/13/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<p>​        类的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>。数据抽象是一种依赖于<strong>接口</strong>和<strong>实现</strong>分离的编程技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员，负责接口实现的函数体以及定义类所需要的各种私有函数。</p>
<a id="more"></a>
<h2 id="一-定义抽象数据类型"><a href="#一-定义抽象数据类型" class="headerlink" title="一.定义抽象数据类型"></a>一.定义抽象数据类型</h2><ul>
<li><p>成员函数通过一个名为this的额外隐式参数来访问它的对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">total.isbn();</span><br><span class="line"><span class="comment">//编译器负责把total的地址传递给isbn的隐式形参this，可认为如下调用：</span></span><br><span class="line">Sales_data::isbn(&amp;total);</span><br><span class="line"></span><br><span class="line"><span class="comment">//this是一个常量指针，我们不允许改变this所保存的地址</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认情况下，this的类型是指向类类型非常量版本的常量指针，这也意味着一般情况下，我们不能把this绑定到一个常量对象上，而如果我们想要让const指向一个常量对象上，我们要将函数定义为常量成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Sales_data::isbn</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;isbn;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Sales_data::isbn</span><span class="params">(<span class="keyword">const</span> Sales_data *<span class="keyword">const</span> <span class="keyword">this</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;isbn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常量成员函数中const的作用可见第二个函数定义</span></span><br><span class="line"><span class="comment">//isbn可以读取调用它的对象的数据成员，但不能写入新值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个返回this对象的函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该函数类似于+=，调用该函数的对象处在运算符左侧，参数处在右侧</span></span><br><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;	<span class="comment">//解引用，并返回调用该函数的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data()=<span class="keyword">default</span>;</span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s):bookNo(s)&#123;&#125;</span><br><span class="line">Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p):</span><br><span class="line">			bookNo(s),units_sold(n),revenue(p*n)&#123;&#125;</span><br><span class="line">Sales_data(<span class="built_in">std</span>::istream &amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Sales_data()=default,此语句要求编译器生成默认构造函数*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二-访问控制与封装"><a href="#二-访问控制与封装" class="headerlink" title="二.访问控制与封装"></a>二.访问控制与封装</h2><ul>
<li><p>class和struct定义类唯一的区别就是默认的访问权限。如果我们希望定义的类所有的成员是public，使用struct；如果使用class，则这些成员是private的。</p>
</li>
<li><p>友元：类允许其它类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元。只需添加一条以friend关键字开始的函数声明语句即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;,<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp;<span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream,Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream,<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元的声明仅仅指定了访问权限，而非通常意义上的函数声明。</span></span><br><span class="line"><span class="comment">//如果我们希望类的用户能调用某友元函数，我们需要在外部专门声明一次</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三-类的其他特性"><a href="#三-类的其他特性" class="headerlink" title="三.类的其他特性"></a>三.类的其他特性</h2><ul>
<li><p>可变数据成员：有时我们希望能修改类的某个数据成员，即使是在一个const成员函数内。我们通过在变量的声明中加入mutable关键字。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> some_member <span class="keyword">const</span> &#123;++access_ctr;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">mutable</span> <span class="keyword">size_t</span> access_ctr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此时尽管some_member函数是const函数，但是仍然能够修改可变数据成员</span></span><br><span class="line"><span class="comment">//一个可变数据成员永远不会是const，即使它是const对象的成员。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类数据成员的初始值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt; screens&#123;Screen(<span class="number">24</span>,<span class="number">80</span>,<span class="string">' '</span>)&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。</span></span><br><span class="line"><span class="comment">//此例我们使用一个单独元素值对vector成员执行了列表初始化</span></span><br><span class="line"><span class="comment">//这个值将被传递给vector&lt;Screen&gt;的构造函数，从而创建单元素vector对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回*this的成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    contents[<span class="built_in">cursor</span>] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Screen &amp;<span class="title">Screen::set</span><span class="params">(pos r,pos col,<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    contents[r*<span class="built_in">width</span> + col] = c;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该函数返回的是对象的引用，而非对象的副本</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它。它在声明之后定义之前是一个不完全类型。</p>
</li>
<li><p>当某类需要用到另一个类里的私有成员时，我们可以用到友元：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ScreenIndex = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Screen&gt;::size_type;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;Screen&gt; screens&#123;Screen(24,80.' ')&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex i)</span></span>&#123;</span><br><span class="line">    Screen &amp;s = screens[i];</span><br><span class="line">    s.contents = <span class="built_in">string</span>(s.<span class="built_in">height</span> * s.<span class="built_in">width</span>,<span class="string">' '</span>);	<span class="comment">//清空Screen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个类想要把一组重载函数声明为友元，那么必须对每一个重载函数分别声明</p>
</li>
</ul>
<h2 id="四-构造函数再探"><a href="#四-构造函数再探" class="headerlink" title="四.构造函数再探"></a>四.构造函数再探</h2><ul>
<li><p>委托构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">  Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s,<span class="keyword">unsigned</span> cnt,<span class="keyword">double</span> price):</span><br><span class="line">    		bookNo(s),units_sold(cnt),revenue(cnt*price)&#123;&#125;</span><br><span class="line">  Sales_data():Sales_data(<span class="string">""</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">  Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s):Sales_data(s,<span class="number">0</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">  Sales_data(<span class="built_in">std</span>::istream &amp;is):Sales_data()&#123;<span class="built_in">read</span>(is,*<span class="keyword">this</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最后一个构造函数同样是委托构造函数，它委托给了默认构造函数，默认构造函数又接着委托给了第一个构造函数。当这些受委托的构造函数执行完，最后执行委托构造函数体的内容。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式类类型转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9 9 9 9"</span>;</span><br><span class="line">item.combine();		<span class="comment">//将item所属类对象相结合</span></span><br><span class="line"><span class="comment">//编译器用给定的string自动创建了一个Sales_data对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>抑制构造函数定义的隐式转换：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们可以通过将构造函数声明为explicit来阻止隐式转换：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line">    Sales_data()=<span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s,<span class="keyword">unsigned</span> n,<span class="keyword">double</span> p):</span><br><span class="line">    		  bookNo(s),units_sold(n),revenue(n*p)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span>:<span class="title">booNo</span><span class="params">(s)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="built_in">std</span>::istream)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//! item.combine(null_book);</span></span><br><span class="line"><span class="comment">//! item.combine(cin);</span></span><br><span class="line"><span class="comment">//以上2种隐式转换是错误的，因为对应的构造函数是explicit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//explicit关键字只允许出现在类内构造函数，在外部定义不应该重复</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>聚合类：使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。</p>
</li>
<li><p>constexpr 构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Debug</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    constexpr Debug(bool b =true):hw(b),io(b),other(b)&#123;&#125;</span><br><span class="line">    constexpr Debug(bool h,bool i,bool o):hw(h),io(i),other(o)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">any</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> hw||io||other;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> hw;</span><br><span class="line">    <span class="keyword">bool</span> io;</span><br><span class="line">    <span class="keyword">bool</span> other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，constexpr构造函数必须有一个空的函数体，即所有成员变量的初始化都放  到初始化列表中。</span></span><br><span class="line"><span class="comment">//constexpr修饰构造函数代表所接收的参数是一个常量表达式</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="五-类的静态成员"><a href="#五-类的静态成员" class="headerlink" title="五.类的静态成员"></a>五.类的静态成员</h2><ul>
<li>类的静态成员存在于任何对象中。同样的，静态成员函数不能与任何对象绑定在一起，它们不包含 <strong>this</strong> 指针。</li>
</ul>
<ul>
<li>成员函数不用通过作用域运算符就能直接使用静态成员。</li>
</ul>
<ul>
<li>因为静态数据成员不属于类的任意一个对象所以它们并不是在创建类的时候被定义的。一般来说，我们必须在类的外部定义和初始化每个静态成员。</li>
</ul>
<ul>
<li><p>如果静态变量应用场景仅限于编译器可以将其替换为某值时，那么我们不必定义它。相反，如果我们将它用于值不能替换的场景中，则该成员必须有一条定义语句。</p>
</li>
<li><p>我们可以使用静态数据成员作为默认实参，而非静态数据成员不行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++Primer》学习笔记（第一部分第六章）</title>
    <url>/2020/05/06/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<ul>
<li><p>本章首先介绍函数的定义和声明，包括参数如何传入函数以及函数如何返回结果。在C++语言中允许重载函数，即几个不同函数共名。所以接下来我们介绍重载函数的方法，以及编译器如何从函数的若干重载形式中选取一个与调用匹配的版本。最后介绍关于函数指针。</p>
<a id="more"></a>
</li>
</ul>
<h2 id="函数基础与参数传递"><a href="#函数基础与参数传递" class="headerlink" title="函数基础与参数传递"></a>函数基础与参数传递</h2><p>1.局部对象：</p>
<ul>
<li>局部静态对象：在函数的局部变量前面加上static修饰，那么该变量在首次进入函数时被初始化后，将不再被重置，在函数体内对它的操作会一直持续到程序结束。</li>
</ul>
<p>2.函数声明：</p>
<ul>
<li><p>函数声明不包括函数体，所以也不必加上形参名字。尽管如此，写上形参的名字还是有用处的，它可以帮助使用者更好理解函数。</p>
</li>
<li><p>我们习惯上将变量与函数的声明放在头文件中，而在源文件定义它们。</p>
</li>
</ul>
<p>3.使用引用避免拷贝：</p>
<ul>
<li>拷贝大的类类型对象或者容器对象比较低效，我们可以使用引用形参，但要注意如果不希望对象被修改，使用引用时要注意。</li>
</ul>
<p>4.使用引用形参返回额外的信息：</p>
<ul>
<li><p>当我们希望函数返回多个值时，我们可以在调用函数定义一个变量来储存返回值，并在被调函数引用该储存变量，如此我们可通过修改该引用来达到返回值的目的。</p>
</li>
<li><p>尽量使用常量引用。</p>
</li>
</ul>
<p>5.传递多维数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>],<span class="keyword">int</span> rowsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>],<span class="keyword">int</span> rowsize)</span></span>;</span><br><span class="line"><span class="comment">//上面二者是等价的</span></span><br><span class="line"><span class="comment">//实际上形参是指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure>
<p>6.main：处理命令行选项</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//第二个形参是一个数组，它的元素指向字符串</span></span><br><span class="line"><span class="comment">//第一个形参表示数组中字符串的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当实参传给main函数后，argv第一个元素指向程序的名字或者空字符串</span></span><br><span class="line"><span class="comment">//接下来的元素依次传递命令行提供的实参，最后一个指针后的元素值为0</span></span><br><span class="line">prog -d -o ofile data0</span><br><span class="line">argv[<span class="number">0</span>]=<span class="string">"prog"</span>;</span><br><span class="line">argv[<span class="number">1</span>]=<span class="string">"-d"</span>;</span><br><span class="line">argv[<span class="number">2</span>]=<span class="string">"-o"</span>;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>7.含有可变形参的函数</p>
<ul>
<li><p>有时我们无法提前预知应该向函数传递几个实参。为了编写能处理不同数量实参的函数，C++11新标准提供了2个方法：</p>
<ol>
<li>如果所有的实参类型相同，可以传递一个名叫initializer_list 的标准库类型。</li>
<li>如果类型不同，可以编写一个特殊函数——可变参数模板</li>
</ol>
</li>
<li><p>initializer_list 形参：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//initializer_list与vector类似，然而前者对象中的元素永远是常数值</span></span><br><span class="line"><span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; ls;</span><br><span class="line"><span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; li;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>();beg != il.<span class="built_in">end</span>();beg++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们的函数首先初始化beg令其表示首元素，然后依次遍历列表中的每个元素</span></span><br><span class="line"><span class="comment">//在循环体中，解引用beg以访问当前元素并输出它的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在传递实参时该如此调用</span></span><br><span class="line"><span class="keyword">if</span>(expected!=actual)</span><br><span class="line">    error_msg(&#123;<span class="string">"functionX"</span>,expected,actual&#125;);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    error_msg(&#123;<span class="string">"functionX"</span>,<span class="string">"okay"</span>&#125;);</span><br><span class="line"><span class="comment">//想向initializer_list形参传递一个值的序列，就必须放在花括号内</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>省略符形参：便于C++程序访问某些特殊的C代码</p>
</li>
</ul>
<h2 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h2><ol>
<li><p>不要返回局部对象的引用或指针。</p>
</li>
<li><p>列表初始化返回值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//expected 和 actual 是string对象</span></span><br><span class="line">    <span class="keyword">if</span>(expected.empty())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(expected==actual)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"functionX"</span>,<span class="string">"okay"</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"functionX"</span>,expected,actual&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数返回vector对象</span></span><br><span class="line"><span class="comment">//如果函数返回的是内置类型，那么花括号包围的列表最多包含一个值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回数组指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下为返回数组指针函数的声明</span></span><br><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//func(int i)表示调用func函数时需要一个int类型的实参</span></span><br><span class="line"><span class="comment">//(*func(int i))意味着我们对函数调用的结果执行解引用操作</span></span><br><span class="line"><span class="comment">//(*func(int i))[10]表示解引用func的调用将得到大小为10的数组</span></span><br><span class="line"><span class="comment">//int (*func(int i))[10]表示数组中元素为int类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用尾置返回类型</span></span><br><span class="line">auto func(int i) -&gt; int(*)[10];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们知道函数返回的指针指向哪个数组，就可以使用decltype声明返回类型</span></span><br><span class="line"><span class="keyword">int</span> odd[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrptr(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>) ? &amp;odd : &amp;even;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//decltype不负责把数组类型转化为对应的指针</span></span><br><span class="line"><span class="comment">//所以如果想表示arrptr返回指针还必须在函数声明时加上*</span></span><br></pre></td></tr></table></figure>
<hr>
</li>
</ol>
<p>5.7号更新：</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><ul>
<li><p>同一作用域的几个函数名字相同但参数列表不同，我们称之为重载函数。</p>
</li>
<li><p>重载和 const 形参：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> phone)</span></span>;		<span class="comment">//重复声明第一项</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(phone* <span class="keyword">const</span>)</span>		<span class="comment">//顶层const，同上</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//以下为底层const的运用</span></span></span><br><span class="line"><span class="function"><span class="comment">//通过区分形参指向的是常量对象还是非常量对象来实现函数重载</span></span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;	<span class="comment">//新函数，作用于常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>;	<span class="comment">//新函数，指向常量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>const_cast和函数重载：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shortstring</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1:s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">shortstring</span><span class="params">(<span class="built_in">string</span> &amp;s1,<span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = shortstring(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1),</span><br><span class="line">                          <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实参强制转化为对const的引用，然后调用第一个函数</span></span><br><span class="line"><span class="comment">//第一个函数返回const string的引用</span></span><br><span class="line"><span class="comment">//最后我们将返回的引用转化为普通的string&amp;，如此完成重载函数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用重载函数：</p>
<ol>
<li>当我们调用函数时，编译器首先寻找对该函数名的声明，找到的是接受int值的那个局部声明。一旦在当前的作用域内找到所需的名字，编译器就会忽略外层作用域中的同名实体。</li>
</ol>
</li>
</ul>
<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><ul>
<li><p>默认实参：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht=<span class="number">24</span>,sz wid=<span class="number">80</span>,<span class="keyword">char</span> backgrnd=<span class="string">' '</span>)</span></span>;</span><br><span class="line"><span class="comment">//一旦某个形参被赋予默认值，它后面所有形参都必须有默认值</span></span><br><span class="line"><span class="comment">//调用方式如下：</span></span><br><span class="line"><span class="built_in">string</span> window;</span><br><span class="line">window=screen();</span><br><span class="line">window=screen(<span class="number">66</span>);</span><br><span class="line">window=screen(<span class="number">66</span>,<span class="number">225</span>);</span><br><span class="line">window=screen(<span class="number">66</span>,<span class="number">256</span>,<span class="string">'#'</span>);</span><br><span class="line"><span class="comment">//从左到右传递实参</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内联函数和constexpr函数：</p>
<p>​    内联函数可以避免函数调用的开销，在函数的返回类型前面加上关键字inline，这样就可以将它声明为内联函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">shorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1,<span class="keyword">const</span> sting &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1:s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果我们如下调用：</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; shorter(s1,s2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//那么编译会将其变为以下形式:</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1:s2) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>​    一般来说，内联机制用于优化规模较小，流程直接，频繁调用的函数。</p>
</li>
<li><p>constexpr 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz();</span><br><span class="line"><span class="comment">//执行初始化任务时，编译器把对constexpr函数的调用替换为结果值。</span></span><br><span class="line"><span class="comment">//constexpr函数被隐式指定为内联函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把内联函数和constexpr函数的声明与定义都放在头文件中</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h2><ul>
<li><p>假如有以下2个重载函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">f(<span class="keyword">double</span>,<span class="keyword">double</span>);</span><br><span class="line"><span class="comment">//编译器最终因为这个调用具有二义性拒绝请求</span></span><br><span class="line"><span class="comment">//因为在每个实参各自都有更好的一面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainp</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mainp</span><span class="params">(<span class="keyword">float</span>)</span></span>;</span><br><span class="line">mainp(<span class="number">3.14</span>);	<span class="comment">//3.14时double类型，所有编译错误，具有二义性</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul>
<li><p>函数指针指向的是函数而非对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">length</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="comment">//函数指针如下：</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;,<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们把函数名作为值来使用，函数自动转化为指针</span></span><br><span class="line">pf = length;</span><br><span class="line">pf = &amp;length;	<span class="comment">//二者是等价的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回指向函数的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*,<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*,<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;		<span class="comment">//f1函数返回指向函数的指针</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;		<span class="comment">//与第一个等价</span></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>*,<span class="keyword">int</span>);	<span class="comment">//等价</span></span><br><span class="line"><span class="comment">//可以使用尾置返回类型</span></span><br><span class="line">auto f1(int)-&gt;int (*)(int*,int);</span><br><span class="line"><span class="comment">//可以使用decltype</span></span><br><span class="line"><span class="keyword">decltype</span>(func) *getFcn(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++Primer》学习笔记（第一部分第二章）</title>
    <url>/2020/04/13/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<p><strong>2020.4.13写：</strong></p>
<a id="more"></a>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li>初始化列表（initialize list）：</li>
</ul>
<p>如以下4个初始化是等价的：</p>
<p>​    int i = 0 ;</p>
<p>​    int i = {0} ;</p>
<p>​    int i{0} ;</p>
<p>​    int i(0) ;</p>
<ul>
<li>变量的声明：</li>
</ul>
<p>​    当我们仅仅是想声明一个变量，而非去定义，我们可以用extern来完成，而当我们用extern去声明一个变量时，我们如果给它初始值，那么extern也就没有意义了。</p>
<ul>
<li>全局变量：</li>
</ul>
<p>​    当我们在函数体外定义了一个全局变量，如果我们在函数体再次定义了该变量，那么在函数体定义的变量会覆盖该全局变量，而不是去修改它。</p>
<p>​    而如果我们想要显式的访问全局变量而不是局部变量，那么我们就要如此调用      ‘ : :i ’。此处：：便是作用域操作符。</p>
<h2 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h2><p>​    引用可以给对象起一个别名，但是该引用本身并不是一个对象。然而引用要注意以下几点：</p>
<pre><code>1. 引用类型必须初始化。因为引用与一个对象绑定以后，不能再改变绑定对象。
 2. 引用类型必须与对象的类型一致，否则会出错。
 3. 引用类型的初始值必须是一个对象。假如你给一个int类型的引用赋予10，那么系统就会报错。
</code></pre><h2 id="指针："><a href="#指针：" class="headerlink" title="指针："></a>指针：</h2><ol>
<li><p>当我们想要将一个指针初始化为空指针，在C语言中我们学过，可以使用NULL（预处理变量）进行初始化，如此那和用0初始化指针本质上没有区别。</p>
<p>所以在C++上，我们更倾向于用 <strong>nullptr</strong> 来将指针初始化为空指针。</p>
</li>
<li><p><strong>void*</strong>是一个特殊的指针类型，它可以存放任意对象的地址，然而我们一般不拿<strong>void*</strong>指针所指的变量来进行比较，因为我们并不知道它所指的对象是什么类型。概括来说，以<strong>void*</strong>的视角看内存空间也仅仅是内存空间，它没办法访问内存空间所存的变量。</p>
</li>
</ol>
<h2 id="const与constexpr-const-expression-限定符："><a href="#const与constexpr-const-expression-限定符：" class="headerlink" title="const与constexpr(const expression) 限定符："></a>const与constexpr(const expression) 限定符：</h2><p>​    const限定符的主要意图就是不想我们在初始化一个变量后再去改变它，所以用const修饰一个变量时，一定要去初始化该变量。</p>
<p>​    默认情况下，const 对象被设定为仅在文件内有效，当多个文件出现同名的const 变量时，等同于在不同文件定义了独立的变量。而如果我们想在多个文件中使用同一个变量，那么我们只要在声明和定义 const 变量的前面加上 extern 就行了。</p>
<ol>
<li><p><strong>const的引用：</strong></p>
<ol>
<li><ol>
<li>​    我们允许将const的引用与非const的对象绑定，那么此处引用的意义就是，我们无法通过该引用来修改所绑定对象的值，但我们可以通过其它途径去修改。当然，如果反过来，我们就不可以将非const的引用与const的对象绑定。</li>
</ol>
</li>
<li><ol>
<li><p>​    如果一个常量引用与一个不同类型变量绑定会发生什么：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;  <span class="comment">//此处是double类型，而引用是int类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure>
<p>​    如此，编译器就会生成一个临时量对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;  <span class="comment">//将double转化为整形常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>指针和const :</strong></p>
<p>2.1. <strong>顶层const与底层const:</strong></p>
<p>​        <strong>顶层const</strong>: 即指针本身就是个常量（如int *const i）,即它不能改变它所存储的地址，即它不能改变它所指的对象。</p>
<p>​        <strong>底层const</strong>: 即指针所指的对象是个常量（如const int *i）,即它不能改变它所指的对象的值。</p>
<p>​    在执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中顶层的const（如int *const i）不受什么影响。而底层const的限制往往不能忽略。即拷入与拷出的对象必须具有相同的底层const资格，或者数据类型能转换。</p>
<p>​    一般来说，非常量可以转换为常量，反之不行。</p>
</li>
<li><p>constexpr 和常量表达式：</p>
<p>​    我们有时很难分辨一个初始值是不是常量表达式。如此，在C++11新标准规定中，允许将变量定义为constexpr,来让编译器验证初始值是否是常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;  <span class="comment">//20是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> limit = mf + <span class="number">1</span>;	<span class="comment">//mf+1是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = <span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//只有当size是一个constexpr函数才是正确的声明语句</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新标准允许定义特殊的constexpr函数</span></span><br><span class="line"><span class="comment">//这个函数要求足够简单到编译时就能得到结果</span></span><br></pre></td></tr></table></figure>
<p>用const和用constexpr限定指针时，含义有所不同：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;	<span class="comment">//p1是指向'整型常量'的指针。底层const</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *p2 = <span class="literal">nullptr</span>	<span class="comment">//p2是指向'整型'的常量指针。顶层const</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p><strong>2020.4.14.写：</strong></p>
<h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><ol>
<li><p>typedef：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;	<span class="comment">//wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base,*p;</span><br><span class="line"><span class="comment">//base同样是double的同义词</span></span><br><span class="line"><span class="comment">//p是double*的同义词</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>using: </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = sales_item;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>当我们的类型别名是一个复合类型或是常量，那使用的时候会有所不同，如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstr;</span><br><span class="line"><span class="keyword">const</span> pstr d=<span class="number">0</span>;		<span class="comment">//此处const是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> pstr *f;		<span class="comment">//f的对象是指向char的常量指针,而f并非常量指针</span></span><br></pre></td></tr></table></figure>
<h4 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h4><p>​    我们常常需要将表达式的值赋予给变量，当我们不知道表达式的值属于什么类型时，我们可以使用auto类型说明符，来让编译器帮我们判断变量的类型。</p>
<ol>
<li>基本数据类型运用：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> item = val1 + val2;	<span class="comment">//item的类型由后面表达式的类型来决定</span></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>,*p = &amp;i;		<span class="comment">//（正确）i是整型变量，p是指向整型变量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>,*p = <span class="number">3.14</span>; <span class="comment">// (错误) 两变量的基本数据类型不一致</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>复合类型，常量中auto的运用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="comment">//auto会忽略掉顶层const，例子如下：</span></span><br><span class="line"><span class="keyword">auto</span> b = ci;	<span class="comment">//此处b只是普通的变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//然而auto不会忽略底层const</span></span><br><span class="line"><span class="keyword">auto</span> *p = &amp;ci;	<span class="comment">//此处p是指向整型常量的指针</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h4><p>​    我们希望从表达式的类型推断出要定义变量的类型，但不想用该表达式的值初始化变量，于是引入了第二种类型说明符decltype，它的作用是选择并返回操作数的数据类型。再此过程中，编译器不去计算表达式的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(f()) sum = x;	<span class="comment">//sum的类型是f()的返回类型</span></span><br><span class="line"><span class="comment">//编译器并不会去调用f,而是在调用f时，将f的返回类型当作sum的类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype处理顶层const与auto有所不同</span></span><br><span class="line"><span class="comment">//如果decltype使用的表达式是一个变量，那么的decltype就会返回该变量的类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>，&amp;y = i;</span><br><span class="line"><span class="keyword">decltype</span>(i) x = <span class="number">0</span>;	<span class="comment">//x的类型是const int，即顶层const</span></span><br><span class="line"><span class="keyword">decltype</span>(y) z = x;	<span class="comment">//z的类型是const int&amp;，因为是引用，所以z必须初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果decltype使用的表达式不是一个变量，那么就会返回表达式对应的类型</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>,*p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r+<span class="number">0</span>) b;	<span class="comment">//b的类型是int，而不是int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c=i;		<span class="comment">//c的类型是int&amp;,而不是int,所以c必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(p) d	<span class="comment">//d的类型是int*</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//对于decltype所用的表达式来说，表达式带上括号与不带上括号有所不同</span></span><br><span class="line"><span class="comment">//如果使用不加括号的变量，那么得到的就是该变量的类型</span></span><br><span class="line"><span class="comment">//如果使用加括号的变量（一层或多层），那就会得到引用类型（变量被当成表达式）</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">decltype</span>((i)) d=i;	<span class="comment">//d的类型是int&amp;,所以必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;	<span class="comment">//e的类型是int</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><h4 id="编写自己的头文件："><a href="#编写自己的头文件：" class="headerlink" title="编写自己的头文件："></a>编写自己的头文件：</h4><p>​    一般情况下，由于类一般不定义在函数体内，并且为了确保各个文件类的定义一致，我们会编写自己的头文件来存放类，而且类所处的文件应该与类的名字一致。</p>
<p>​    预处理器：确保头文件能正常工作的常用技术是预处理器，预处理器可以部分改变我们所编写的程序，比如他们看到#include时，会将其替换为该头文件的内容。</p>
<p>​    头文件保护符：头文件保护符依赖于预处理变量，#define把一个名字设定为预处理变量，另两个指令（#ifdef , #ifndef ）检查某个指定预处理变量是否一定义。如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>	SALE_H		<span class="comment">//当预处理变量已定义时，执行此命令，忽略后面内容</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALE_H		<span class="comment">//当未定义时，预处理器顺序执行，直至遇到#endif为止</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;	//当需要用到头文件中的类时，我们可以包含头文件</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sale</span>&#123;</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>整个程序预处理变量包括头文件必须唯一，通常做法就是利用类名创建头文件。</li>
</ul>
<h2 id="相较C语言的新知识"><a href="#相较C语言的新知识" class="headerlink" title="相较C语言的新知识"></a>相较C语言的新知识</h2><ol>
<li><p>引用：相当于为一个变量起一个别名，然而这个别名并不是对象。</p>
</li>
<li><p>对指针的初始化：我们更应该取用 nullptr ,而不是NULL。</p>
</li>
<li>底层const：所指的对象时常量</li>
<li>顶层const：自身是常量</li>
<li>auto说明符：用未知类型的表达式给变量初始化时可以auto说明该变量，让编译器自己判断变量应该是什么类型。</li>
<li>decltype：想定义一个与类型未知的表达式类型一致的变量，并且需要自己初始化该变量的值时，可以使用decltype。</li>
</ol>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++Primer》学习笔记（第一部分第三章）</title>
    <url>/2020/04/20/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一-命名空间的using声明"><a href="#一-命名空间的using声明" class="headerlink" title="一.命名空间的using声明"></a><strong>一.命名空间的using声明</strong></h2><ul>
<li>我们目前使用到的库函数基本上都属于命名空间std。如std::cin。此处的‘：：’作用域操作符的含义是：</li>
</ul>
<p>​    <em>编译器从操作符左侧的名字所示的作用域中寻找右侧那个名字。</em></p>
<a id="more"></a>
<ol>
<li><p>我们可以使用using声明，来免去专门的前缀（如命名空间：：）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name ;</span><br><span class="line"><span class="comment">//例子如下：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;		</span><br><span class="line"><span class="comment">//如此声明，那么可以直接使用cin。</span></span><br><span class="line"><span class="comment">//然而其他的由于没有声明，如果直接使用（如cout），那么会报错</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="二-标准库类型string"><a href="#二-标准库类型string" class="headerlink" title="二.标准库类型string"></a><strong>二.标准库类型string</strong></h2><ul>
<li><p>string表示可变长的字符序列，使用string类型必须包含string头文件。注意，string定义再命名空间std中，所以下面假定已包含以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="1-定义和初始化string对象"><a href="#1-定义和初始化string对象" class="headerlink" title="1.定义和初始化string对象"></a>1.定义和初始化string对象</h5><ul>
<li><p>初始化对象常用方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stirng s1;		<span class="comment">//得到空的string</span></span><br><span class="line"><span class="built_in">string</span> s2=s1;	<span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s3=<span class="string">"hiya"</span>;	<span class="comment">//直接赋给s3</span></span><br><span class="line"><span class="built_in">string</span> s4=(<span class="number">10</span>,<span class="string">'c'</span>);		<span class="comment">//内容是10个c</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-string对象上的操作"><a href="#2-string对象上的操作" class="headerlink" title="2.string对象上的操作"></a>2.string对象上的操作</h5><ul>
<li><p>string的操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s,is;</span><br><span class="line">getline(is,s)	</span><br><span class="line"><span class="comment">//从is读取一行赋给s（换行符也被读取，但是不赋予），返回is</span></span><br><span class="line">s.empty();		<span class="comment">//s为空返回true</span></span><br><span class="line">s.<span class="built_in">size</span>();		<span class="comment">//返回s中的字符个数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>getline（），empty（），size（）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//empty()：</span></span><br><span class="line"><span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>,<span class="built_in">line</span>))</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">line</span>.enpty())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//如果读到空行就直接跳过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//size()：</span></span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>,<span class="built_in">line</span>))</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">line</span>.<span class="built_in">size</span>() &gt; <span class="number">80</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出其中超过80字符的行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>string::size_type类型</p>
<p>对于size函数来说，它返回的并不是int或是unsigned类型，而是<strong>string::size_type</strong>类型。</p>
<p><strong>注意：size函数返回的是无符号类型的数，所以在表达式中不应该混用int类型的数</strong></p>
</li>
<li><p>比较string对象</p>
</li>
</ul>
<p>在使用字符串加法时，必须要确保+号两边至少有一个string对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s3=s1+s2;</span><br><span class="line"><span class="built_in">string</span> s4=s1+<span class="string">","</span>;</span><br><span class="line"><span class="built_in">string</span> s5=s1+<span class="string">","</span>+<span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">//由于加法是从左到右的，所以实际上第二个加号左侧仍然是string对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! string s6=","+"hello"+s1;</span></span><br><span class="line"><span class="comment">//很明显，上式的第一个加号的两侧都不是string对象，所以出错</span></span><br></pre></td></tr></table></figure>
<h5 id="3-处理string对象中的字符"><a href="#3-处理string对象中的字符" class="headerlink" title="3.处理string对象中的字符"></a>3.处理string对象中的字符</h5><p>​    为了单独处理string字符串某个特定字符，完成一些特定的功能，在cctype头文件中定义了一组标准库函数处理这部分工作。：</p>
<p><img src="http://www.morenmoren.com/cctype.png" alt=""></p>
<ul>
<li><strong>范围for语句</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for(declaration:expression)</span></span><br><span class="line"><span class="comment">//    statement</span></span><br><span class="line"><span class="comment">//expression是一个对象，而declaration则是定义一个变量。</span></span><br><span class="line"><span class="comment">//每次循环都会被初始化为expression的下一个元素值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.每行输出一个字符串的一个字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str1</span><span class="params">(<span class="string">"some"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c : str1)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.统计string对象的标点符号的个数</span></span><br><span class="line"><span class="keyword">decltype</span>(s.<span class="built_in">size</span>()) cnt=<span class="number">0</span>;	</span><br><span class="line"><span class="comment">//将size()返回值类型作为cnt的类型，使代码的可读性更好。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c:s)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ispunct</span>(c))	<span class="comment">//判断c是不是标点符号</span></span><br><span class="line">        ++cnt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.改变字符串的字符（利用引用）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s)</span><br><span class="line">    c = <span class="built_in">toupper</span>（c）	<span class="comment">//将不是大写字符的字符变成大写字符</span></span><br><span class="line"><span class="comment">//由于c是当前字符的引用，所以可以通过改变c来改变字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h2 id="三-标准库类型vector"><a href="#三-标准库类型vector" class="headerlink" title="三.标准库类型vector"></a><strong>三.标准库类型vector</strong></h2><p>​    vector表示对象的集合，其中所有对象类型相同。，要想使用vector，必须包含适当的头文件——#include <vector>。它同样处于命名空间std中。</p>
<p>​    模板本身不是类或函数，相反可以将模板作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化，所以当使用模板时，需要指出编译器应该把类或函数实例化为什么类型。（<strong>vector是类模板</strong>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;	<span class="comment">//保存int类型对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Sales_item&gt; Sales_vec;	<span class="comment">//保存Sales_item类型对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;	<span class="comment">//保存vector对象</span></span><br><span class="line"><span class="comment">//引用不是对象，所以vector不包含引用</span></span><br></pre></td></tr></table></figure>
<h5 id="1-定义和初始化vector对象"><a href="#1-定义和初始化vector对象" class="headerlink" title="1.定义和初始化vector对象"></a>1.定义和初始化vector对象</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.vector的拷贝</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span> <span class="comment">//注意，在拷贝时，必须保持两vector类型一致</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 2.列表初始化vector对象</span></span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1</span>&#123;<span class="string">"a"</span>,<span class="string">"an"</span>&#125;;</span><br><span class="line"><span class="comment">//!vector&lt;string&gt; v1("a","an");不可以使用圆括号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.用vector对象容纳个数和统一初始值来初始化vector对象</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>,<span class="number">-1</span>)</span>		<span class="comment">//10个int类型元素被初始化为-1</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//4.值初始化</span></span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span>	<span class="comment">//编译器帮你初始化这10个元素</span></span></span><br></pre></td></tr></table></figure>
<h5 id="2-向vector对象中添加元素"><a href="#2-向vector对象中添加元素" class="headerlink" title="2.向vector对象中添加元素"></a>2.向vector对象中添加元素</h5><p>​    我们可以利用vector的成员函数push_back向其中添加元素。push_back负责将一个值当作vector对象的尾函数压入到vector对象的尾部。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;++i)</span><br><span class="line">    v2.push_back(i);	<span class="comment">//依次将整数值i压入vector对象中</span></span><br><span class="line"><span class="comment">//结束后vector对象有100个元素，为0~99。</span></span><br><span class="line"><span class="comment">//一般情况下我们还是将vector对象设为空</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注：如果循环体内包含有向vector对象添加元素的语句，就不能使用范围for。(于5.4.3节详细解释)</strong></li>
</ul>
<h5 id="3-其他vector操作"><a href="#3-其他vector操作" class="headerlink" title="3.其他vector操作"></a>3.其他vector操作</h5><ul>
<li><p>vector的许多操作与string类似，如empty(),size()等。同样，访问vector对象中元素的方法与访问string对象中字符的方法也差不多。</p>
</li>
<li><p>不能用下标形式去添加元素：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span>((<span class="keyword">decltype</span>)(v1.<span class="built_in">size</span>()) ix=<span class="number">0</span>; ix!=<span class="number">0</span> ; ++ix)</span><br><span class="line">    v1.push_back(ix);</span><br><span class="line"><span class="comment">//! v1[ix] = ix;	空对象，无法访问该下标</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="四-迭代器介绍"><a href="#四-迭代器介绍" class="headerlink" title="四.迭代器介绍"></a><strong>四.迭代器介绍</strong></h2><h5 id="1-使用迭代器"><a href="#1-使用迭代器" class="headerlink" title="1.使用迭代器"></a><strong>1.使用迭代器</strong></h5><ul>
<li>我们可以通过下标来访问string对象的字符或者是vector对象的元素。还要另一个更通用的机制也可以实现同样的目的，这就是迭代器。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//v表示的是对象。</span></span><br><span class="line"><span class="comment">//b表示的是v的第一个元素，e表示v的尾元素的下一个位置</span></span><br><span class="line"><span class="keyword">auto</span> b=v.<span class="built_in">begin</span>(),e=v.<span class="built_in">end</span>();		<span class="comment">//b，e的类型相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果容器为空，那么begin和end返回的是同一个迭代器</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>迭代器的运算符：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将string对象的每个字符都改为大写字母</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"..."</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x=s.<span class="built_in">begin</span>() ; x!=s.<span class="built_in">end</span>() &amp;&amp; !<span class="built_in">isspace</span>(*x) ; ++x)</span><br><span class="line">    *x=<span class="built_in">toupper</span>(*x);</span><br><span class="line"><span class="comment">//结束条件是迭代器指向尾部的下一个元素，或者是迭代器指向空格</span></span><br><span class="line"><span class="comment">//++x代表，每循环一次就让迭代器指向下一个元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//iterator类型可以修改它所指向的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="built_in">string</span>::iterator it2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const_iterator类型不能修改它所指向的对象，只能访问</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;</span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了专门得到const_iterator类型的迭代器，可以使用cbegin(),cend()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结合解引用和成员的访问操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p是vector，其对象是string类型，以下去检查对象是否为空</span></span><br><span class="line">(*p).empty();</span><br><span class="line">p-&gt;empty();</span><br><span class="line"><span class="comment">//以上是两种进行解引用和成员访问的操作</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注：凡是使用了迭代器的循环体，都不要想迭代器所指的容器添加元素。</strong></p>
</li>
</ul>
<h5 id="2-迭代器运算"><a href="#2-迭代器运算" class="headerlink" title="2.迭代器运算"></a>2.迭代器运算</h5><ul>
<li><p>迭代器的算术运算：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可令迭代器和一个整数相加（相减），即向前（向后）移动若干位置</span></span><br><span class="line"><span class="keyword">auto</span> mid = vi.<span class="built_in">begin</span>() + vi.<span class="built_in">size</span>()/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//该迭代器指向vector对象中间的元素</span></span><br><span class="line"><span class="keyword">if</span>(it &lt; mid)		<span class="comment">//迭代器可以作比较</span></span><br><span class="line">    <span class="comment">//处理前半部分的元素</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>利用迭代器完成二分查找：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> beg = <span class="built_in">text</span>.<span class="built_in">begin</span>(),<span class="built_in">end</span> = <span class="built_in">text</span>.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = <span class="built_in">text</span>.<span class="built_in">begin</span>() + (<span class="built_in">end</span>-beg)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(mid!=<span class="built_in">end</span> &amp;&amp; *mid!=sought)&#123;</span><br><span class="line">    <span class="keyword">if</span>(sought &lt; *mid)</span><br><span class="line">        <span class="built_in">end</span> = mid;</span><br><span class="line">	<span class="keyword">if</span>(sought &gt; *mid)</span><br><span class="line">        beg = mid+<span class="number">1</span>;</span><br><span class="line">	mid = beg + (<span class="built_in">end</span>-beg)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五-数组"><a href="#五-数组" class="headerlink" title="五.数组"></a><strong>五.数组</strong></h2><h5 id="1-定义和初始化内置数组"><a href="#1-定义和初始化内置数组" class="headerlink" title="1.定义和初始化内置数组"></a><strong>1.定义和初始化内置数组</strong></h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];	<span class="comment">//ptrs是含有10个整数指针的数组</span></span><br><span class="line"><span class="keyword">int</span> (*parray)[<span class="number">10</span>];	<span class="comment">//指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;attref)[<span class="number">10</span>];	<span class="comment">//attref引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
<h5 id="2-访问数组元素"><a href="#2-访问数组元素" class="headerlink" title="2.访问数组元素"></a><strong>2.访问数组元素</strong></h5><p>​    在使用数组下标时，通常将其定义为size_t类型。</p>
<p>​    我们必须要防止数组越界。        </p>
<h5 id="3-指针和数组"><a href="#3-指针和数组" class="headerlink" title="3.指针和数组"></a><strong>3.指针和数组</strong></h5><ul>
<li><p>指针也是迭代器</p>
</li>
<li><p>标准库函数begin和end：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;...&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ia);	<span class="comment">//指向ia的首元素的指针</span></span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">end</span> = <span class="built_in">end</span>(ia);		<span class="comment">//指向ia尾元素下一个位置的指针</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="4-C风格字符串"><a href="#4-C风格字符串" class="headerlink" title="4.C风格字符串"></a><strong>4.C风格字符串</strong></h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(p)	<span class="comment">//返回p的长度，空字符不计入</span></span><br><span class="line"><span class="built_in">strcmp</span>(p1,p2)	<span class="comment">//比较p1,p2,相等返回0。p1&gt;p2返回正值。p1&lt;p2返回负值</span></span><br><span class="line"><span class="built_in">strcat</span>(p1,p2)	<span class="comment">//将p2附加到p1后面</span></span><br><span class="line"><span class="built_in">strcpy</span>(p1,p2)	<span class="comment">//将p2拷贝给p1</span></span><br></pre></td></tr></table></figure>
<h5 id="5-与旧代码接口"><a href="#5-与旧代码接口" class="headerlink" title="5.与旧代码接口"></a><strong>5.与旧代码接口</strong></h5><ul>
<li><p>使用数组初始化vector对象：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> int_array[] = &#123;...&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="built_in">begin</span>(int_array),<span class="built_in">end</span>(int_array))</span></span>;</span><br><span class="line"><span class="comment">//上述代码最终，ivec将包含array的所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下述代码可以指定一部分</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(int_array + <span class="number">1</span>,int_array + <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="comment">//用3个元素创建了vector对象，分别来自数组下标为1，2，3的元素</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="6-多维数组"><a href="#6-多维数组" class="headerlink" title="6.多维数组"></a><strong>6.多维数组</strong></h5><ul>
<li>多维数组其实就是数组的数组。</li>
</ul>
<h2 id="六-小结"><a href="#六-小结" class="headerlink" title="六.小结"></a>六.小结</h2><ol>
<li>迭代器： <code>auto b=v.begin(),e=v.end();</code></li>
<li>vector：可用于存放相同类型的对象：<code>vector&lt;T&gt;  ivec;</code></li>
<li>push_back：向vector对象末尾添加元素。</li>
</ol>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>《C++Primer》学习笔记（第一部分第四·五章）</title>
    <url>/2020/04/26/%E3%80%8AC++Primer%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E7%AC%AC%E5%9B%9B%C2%B7%E4%BA%94%E7%AB%A0%EF%BC%89/</url>
    <content><![CDATA[<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h2><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ul>
<li><p>重载运算符：当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予另一层含义，所以称之为重载运算符。</p>
<a id="more"></a>
</li>
</ul>
<h2 id="2-条件运算符"><a href="#2-条件运算符" class="headerlink" title="2.条件运算符"></a>2.条件运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cond?expr1:expr2;</span><br><span class="line"><span class="comment">//cond是判断条件的表达式，若为真，返回expr1，为假，返回expr2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套条件运算符</span></span><br><span class="line">fianlgrade = (grade&gt;<span class="number">90</span>)?<span class="string">"high Pass"</span>:(grade&lt;<span class="number">60</span>)?<span class="string">"fail"</span>:<span class="string">"Pass"</span>;</span><br><span class="line"><span class="comment">//若大于90，则直接返回high Pass,否则执行之后的语句，即再来一次判断</span></span><br></pre></td></tr></table></figure>
<h2 id="3-sizeof运算符"><a href="#3-sizeof运算符" class="headerlink" title="3.sizeof运算符"></a>3.sizeof运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data data,*p;</span><br><span class="line"><span class="keyword">sizeof</span>(Sales_data);		<span class="comment">//储存Sales_data类型的对象所占空间大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data;	<span class="comment">//data所属类型的大小</span></span><br></pre></td></tr></table></figure>
<h2 id="4-显示类型转换"><a href="#4-显示类型转换" class="headerlink" title="4.显示类型转换"></a>4.显示类型转换</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static_cast</span></span><br><span class="line"><span class="keyword">double</span> slope=<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j)/i;	<span class="comment">//利用显示类型转换可以关闭警告</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const_cast</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p=<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);</span><br><span class="line"><span class="comment">//如此做相当于抛弃了pc的const性质，编译器将不再阻止我们对它进行写操作</span></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h4 id="try语句块和异常处理："><a href="#try语句块和异常处理：" class="headerlink" title="try语句块和异常处理："></a>try语句块和异常处理：</h4><ul>
<li><p>​    异常是指存在于运行时的反常行为，这些行为超过了函数的正常功能范围。典型的异常包括失去数据库的连接，以及遇到意外的输入等。处理这些反常行为可能是设计所有系统最难的一部分。</p>
</li>
<li><p>异常处理包括：</p>
<ol>
<li>throw表达式，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发了异常。</li>
<li>try语句块，try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称作为异常处理代码。</li>
<li>一套异常类，用于在throw表达式和相关的catch子句之间传递异常的具体信息。</li>
</ol>
</li>
</ul>
<h5 id="throw表达式"><a href="#throw表达式" class="headerlink" title="throw表达式"></a>throw表达式</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_item item1,item2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2;</span><br><span class="line"><span class="keyword">if</span>(item1.isbn() != item2.isbn())</span><br><span class="line">    <span class="keyword">throw</span> runtime_error(<span class="string">"Data must refer to same ISBN"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; item1+item2 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//如果ISBN不一样，就抛出异常，不再执行当前函数</span></span><br><span class="line"><span class="comment">//并把控制权转移给能处理该异常的代码</span></span><br></pre></td></tr></table></figure>
<h5 id="try语句块"><a href="#try语句块" class="headerlink" title="try语句块"></a>try语句块</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; item1 &gt;&gt; item2)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(item1.isbn() != item2.isbn())</span><br><span class="line">    <span class="keyword">throw</span> runtime_error(<span class="string">"Data must refer to same ISBN"</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; item1+item2 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span>(runtime_error err)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; err.what() &lt;&lt; <span class="string">"\nTry again?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">cin</span> || c== <span class="string">'n'</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h5><ul>
<li>exception 头文件定义了最通用的异常类exception。它只报告异常的发生。</li>
<li>stdexcept头文件定义了几种常用的异常类。</li>
<li>new头文件定义了bad_alloc异常类型。</li>
<li>type_info头文件定义了bad_cast异常类型。</li>
</ul>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>二维数组类</title>
    <url>/2020/05/07/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%B1%BB/</url>
    <content><![CDATA[<p>​    在编写二维数组类之前我一直认为二维指针与二维数组是等价，其实不然。二维指针是指向指针的指针，而二维数组是指向数组的数组。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*pp)[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> pp[][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//以上2个是等价的。</span></span><br></pre></td></tr></table></figure>
<p>下面是我编写的二维数组数组类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span>** <span class="built_in">point</span>;</span><br><span class="line">	<span class="keyword">int</span> row,column;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Array(<span class="keyword">int</span> i,<span class="keyword">int</span> j);</span><br><span class="line">	Array(<span class="keyword">int</span> a[][<span class="number">4</span>], <span class="keyword">int</span> row, <span class="keyword">int</span> column);</span><br><span class="line">	~Array();</span><br><span class="line">	<span class="keyword">int</span>* <span class="keyword">operator</span> [](<span class="keyword">int</span> i);	<span class="comment">//对[]运算符重载</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Row</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> row; &#125;	<span class="comment">//返回行标</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Column</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> column;&#125;	<span class="comment">//返回列标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Array::Array(<span class="keyword">int</span> i,<span class="keyword">int</span> j) &#123;</span><br><span class="line">	<span class="keyword">int</span> count1, count2;</span><br><span class="line">	row = i;</span><br><span class="line">	column = j;</span><br><span class="line">	<span class="built_in">point</span> = <span class="keyword">new</span> <span class="keyword">int</span>* [i];</span><br><span class="line">    <span class="comment">//创造一个二维数组</span></span><br><span class="line">	<span class="keyword">for</span> (count1 = <span class="number">0</span>; count1 &lt; i; count1++)&#123;</span><br><span class="line">		<span class="built_in">point</span>[count1] = <span class="keyword">new</span> <span class="keyword">int</span>[j];</span><br><span class="line">		<span class="keyword">for</span> (count2 = <span class="number">0</span>; count2 &lt; j; count2++)</span><br><span class="line">			<span class="built_in">point</span>[count1][count2] = count2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处应该注意：不能写成二维指针，必须写成这种形式或者(*a)[4]形式</span></span><br><span class="line">Array::Array(<span class="keyword">int</span> a[][<span class="number">4</span>],<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;</span><br><span class="line">	<span class="keyword">int</span> count1,count2;</span><br><span class="line">	row = i;</span><br><span class="line">	column = j;</span><br><span class="line">	<span class="built_in">point</span> = <span class="keyword">new</span> <span class="keyword">int</span>* [i];</span><br><span class="line">    <span class="comment">//创建类二维数组，并将传入的二维数组拷贝到类的二维数组</span></span><br><span class="line">	<span class="keyword">for</span> (count1 = <span class="number">0</span>; count1 &lt; i; count1++) &#123;</span><br><span class="line">		<span class="built_in">point</span>[count1] = <span class="keyword">new</span> <span class="keyword">int</span>[j];</span><br><span class="line">		<span class="keyword">for</span> (count2 = <span class="number">0</span>; count2 &lt; j; count2++)</span><br><span class="line">			<span class="built_in">point</span>[count1][count2] = a[count1][count2];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array::~Array() &#123;</span><br><span class="line">	<span class="keyword">delete</span>(<span class="built_in">point</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指针，指向数组的第i项</span></span><br><span class="line"><span class="keyword">int</span>* Array::<span class="keyword">operator</span> [](<span class="keyword">int</span> i) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">point</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化二维数组</span></span><br><span class="line">	<span class="keyword">int</span> pointer[<span class="number">3</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">//两种重载函数的调用</span></span><br><span class="line">	<span class="function">Array <span class="title">array1</span><span class="params">(pointer, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">	<span class="function">Array <span class="title">array2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="comment">//打印该二维数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array1.Row(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array1.Column(); j++)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; array1[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array2.Row(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array2.Column(); j++)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; array2[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>制作简易的网页</title>
    <url>/2020/04/24/%E5%88%B6%E4%BD%9C%E7%AE%80%E6%98%93%E7%9A%84%E7%BD%91%E9%A1%B5/</url>
    <content><![CDATA[<p>​    <strong>上周跟着老师的步骤做了一个自己的网页，还挺有意思的。</strong></p>
<a id="more"></a>
<ol>
<li><p>首先利用css来对网页的风格进行设置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;<span class="attribute">color</span>:white;&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;<span class="attribute">color</span>:white;&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:white;<span class="attribute">text-align</span>:center;&#125;</span><br><span class="line">//设置网页主题风格</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">color</span>: wheat;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">    <span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">'../imag/image1.jpg'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用HTML，JavaScript实现想要的功能（四则运算）：</p>
<p>2.1 建立网页的外观：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  	 // 导入JavaScript文件</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/tocircum.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"computedemo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">！--定义变量来存储你输入的数字--</span>&gt;</span></span><br><span class="line">    请输入数字：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"txt_a"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"请选择运算符"</span> <span class="attr">id</span>=<span class="string">"computetype"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 下面的为要实现的函数（加减乘除） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"add"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"minus"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"multiply"</span>&gt;</span>*<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"divide"</span>&gt;</span>/<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"txt_b"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    =</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"txt_c"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">"btn_compute"</span> <span class="attr">value</span>=<span class="string">"点我计算"</span> <span class="attr">onclick</span>=<span class="string">"compute()"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.2 实现函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Number</span>(a)+<span class="built_in">Number</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minus</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compute</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="built_in">document</span>.getElementById(<span class="string">'txt_a'</span>).value;</span><br><span class="line">    <span class="keyword">var</span> b=<span class="built_in">document</span>.getElementById(<span class="string">'txt_b'</span>).value;</span><br><span class="line">    <span class="keyword">var</span> type=<span class="built_in">document</span>.getElementById(<span class="string">'computetype'</span>).value;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="string">''</span>||b==<span class="string">''</span>)&#123;</span><br><span class="line">        alert(<span class="string">"输入参数！"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> y;</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="string">'add'</span>)&#123;</span><br><span class="line">            y=add(a,b);</span><br><span class="line">            alert(<span class="string">"加的结果是："</span>+y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="string">'minus'</span>)&#123;</span><br><span class="line">            y=minus(a,b);</span><br><span class="line">            alert(<span class="string">"减的结果是："</span>+y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="string">'multiply'</span>)&#123;</span><br><span class="line">            y=multiply(a,b);</span><br><span class="line">            alert(<span class="string">"乘的结果是："</span>+y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="string">'divide'</span>)&#123;</span><br><span class="line">            y=divide(a,b);</span><br><span class="line">            alert(<span class="string">"除的结果是："</span>+y);</span><br><span class="line">             &#125;</span><br><span class="line">        &lt;!-- 将结果输出给等号后面的空位 --&gt;</span><br><span class="line">             <span class="built_in">document</span>.getElementById(<span class="string">'txt_c'</span>).value=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>之后进行首页的制作：</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 导入css文件	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"css/myfirstcss.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--这里我将页面分块，这样更有观赏性--&gt;</span></span><br><span class="line">    </span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"menu"</span> <span class="attr">style</span>=<span class="string">"text-align:center;height:500px;width: 150px;float:left;"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">b</span>&gt;</span>菜单<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--利用HTML实现时间安排表，再利用JavaScript实现四则运算	--&gt;</span>   </span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">"color: burlywood;"</span> <span class="attr">href</span>=<span class="string">"mytable.html"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>时间安排表<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">"color: burlywood;"</span> <span class="attr">href</span>=<span class="string">"tocircum.html"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>四则运算<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"content"</span> <span class="attr">style</span>=<span class="string">"height:200px;width:400px;float:left;"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h2</span> &gt;</span>卷福<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>	<span class="attr">style</span>=<span class="string">"text-align: center;"</span>&gt;</span></span><br><span class="line">			本尼迪克特·康伯巴奇（Benedict Cumberbatch），1976年7月19日出			生于英国伦敦，英国演员、制片人。</span><br><span class="line">			2000年，康伯巴奇出演电视剧《心跳》，开始演艺生涯。</span><br><span class="line">			2010年，开始主演电视系列剧《神探夏洛克》，凭借剧集，获得艾美			奖、金卫星奖等多项最佳男主角奖，亦得到金球奖最佳男主角提名。</span><br><span class="line">			2011年，因舞台剧《弗兰肯斯坦》获得奥利弗奖等最佳男主角奖。2013				年，成立制作公司SunnyMarch。</span><br><span class="line">			2014年，凭影片《模仿游戏》获得好莱坞电影奖最佳男主角奖，和奥斯			 卡金像奖、金球奖、英国电影学院奖等最佳男主角提名，</span><br><span class="line">			并入选《时代周刊》年度“全球最具影响力人物”榜单，更再度登上该杂			志美国版及国际版12月号封面。</span><br><span class="line">			2015年，被英国女王授予大英帝国司令勋章（CBE），并受邀加入美国			  电影艺术与科学学院。</span><br><span class="line">			2016年，开始主演漫威系列电影《奇异博士》。</span><br><span class="line">			2019年，凭电视剧《梅尔罗斯》获得英国电视学院奖最佳男主角奖。</span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span>	<span class="attr">style</span>=<span class="string">"text-align: right; color: red;"</span>&gt;</span></span><br><span class="line">			如果想访问特定的网页请看左侧菜单栏</span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下为实现效果：</p>
<p><img src="http://www.morenmoren.com/firsthtml.png" alt=""></p>
<p><img src="http://www.morenmoren.com/jsplus.png" alt=""></p>
]]></content>
      <categories>
        <category>HTML/css/javascript</category>
      </categories>
      <tags>
        <tag>网页制作</tag>
      </tags>
  </entry>
  <entry>
    <title>学生管理系统（持续更新）</title>
    <url>/2020/04/08/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    <content><![CDATA[<p>​    最近一直在学习C++，就想着用C++语言自己做一个程序，就先从最简单的开始吧——学生管理系统（随着我的能力提高会逐步完善该程序）</p>
<a id="more"></a>
<p><strong>大致思路</strong>（<strong>利用思维导图给出</strong>）：</p>
<p><img src="http://www.morenmoren.com/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B01.png" alt="大致思路"></p>
<p><em>源码如下：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu_data</span> &#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="built_in">string</span> sex;</span><br><span class="line">	<span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">&#125;Data;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Data data;</span><br><span class="line">	Student* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linklist</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	Student* head;</span><br><span class="line">	Student* rear;      <span class="comment">//作为末节点</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Linklist();</span><br><span class="line">	~Linklist();</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Createlist</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Attach</span><span class="params">(<span class="built_in">string</span> name,<span class="built_in">string</span> sex,<span class="keyword">int</span> num,Student**rear)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Showlist</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		利用函数的重载来对不同类型的输入对象，选择如何进行检索，</span></span><br><span class="line"><span class="comment">		同时将该函数类型定义为Student*，在找到所要找的对象时，返</span></span><br><span class="line"><span class="comment">		回其所在链表的位置P。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Student* <span class="title">Searchlist</span><span class="params">(<span class="built_in">string</span> name)</span></span>;</span><br><span class="line">	<span class="function">Student* <span class="title">Searchlist</span><span class="params">(<span class="keyword">int</span> num)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Deletedata</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Changelist</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	Linklist L;</span><br><span class="line">	L.Createlist();</span><br><span class="line">	L.Showlist();</span><br><span class="line">	L.Deletedata();</span><br><span class="line">	L.Showlist();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Linklist::Linklist() &#123;</span><br><span class="line">	n = <span class="number">0</span>;</span><br><span class="line">	head = <span class="keyword">new</span> Student;</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	rear = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Linklist::~Linklist() &#123;</span><br><span class="line">	<span class="keyword">delete</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Linklist::Createlist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> name, sex;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"请按以下格式输入信息:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"学号，姓名，性别"</span> &lt;&lt;<span class="built_in">endl</span> ;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt; num &amp;&amp; num!=<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; name &gt;&gt; sex;</span><br><span class="line">		Attach(name, sex, num, &amp;rear);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i;       <span class="comment">//返回有多少个节点（即有多少个人），暂时不需要</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//该Attach函数是在链表尾部添加新节点，并且rear始终作为链表末节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Linklist::Attach</span><span class="params">(<span class="built_in">string</span> name, <span class="built_in">string</span> sex, <span class="keyword">int</span> num,Student**rear)</span> </span>&#123;</span><br><span class="line">	Student* P;</span><br><span class="line">	P = <span class="keyword">new</span> Student;</span><br><span class="line">	P-&gt;data.name = name;</span><br><span class="line">	P-&gt;data.sex = sex;</span><br><span class="line">	P-&gt;data.num = num;</span><br><span class="line">	P-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	(*rear)-&gt;next = P;</span><br><span class="line">	(*rear) = P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Linklist::Showlist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Student* P;</span><br><span class="line">	P = head;</span><br><span class="line">	<span class="keyword">while</span> (P-&gt;next) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"姓名:"</span> &lt;&lt; P-&gt;next-&gt;data.name</span><br><span class="line">			 &lt;&lt; <span class="string">" 性别："</span> &lt;&lt; P-&gt;next-&gt;data.sex</span><br><span class="line">			 &lt;&lt; <span class="string">" 学号:"</span> &lt;&lt; P-&gt;next-&gt;data.num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		P = P-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student* <span class="title">Linklist::Searchlist</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">	Student* P;</span><br><span class="line">	P = head;</span><br><span class="line">		<span class="keyword">while</span> (P-&gt;next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (P-&gt;next-&gt;data.name == name) &#123;</span><br><span class="line">				<span class="keyword">return</span> P;</span><br><span class="line">			&#125;</span><br><span class="line">			P = P-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"未能找到相关信息"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student* <span class="title">Linklist::Searchlist</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	Student* P;</span><br><span class="line">	P = head;</span><br><span class="line">		<span class="keyword">while</span> (P-&gt;next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (P-&gt;next-&gt;data.num == num) &#123;</span><br><span class="line">				<span class="keyword">return</span> P;</span><br><span class="line">			&#125;</span><br><span class="line">			P = P-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"未能找到相关信息"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Linklist::Deletedata</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> name,choice;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	Student* P=<span class="keyword">new</span> Student;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"你要以何种方式（num/name）删除信息："</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line">	<span class="keyword">if</span> (choice == <span class="string">"num"</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"你要删除哪个学号信息："</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">		P = Searchlist(num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (choice == <span class="string">"name"</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"你要删除哪个学生信息："</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">		P = Searchlist(name);</span><br><span class="line">	&#125;</span><br><span class="line">	Student* T=<span class="keyword">new</span> Student;</span><br><span class="line">	T = P-&gt;next-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> P-&gt;next;</span><br><span class="line">	P-&gt;next = T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Linklist::Changelist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> name, choice;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	Student* P = <span class="keyword">new</span> Student;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"你要以何种方式（num/name）修改信息："</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line">	<span class="keyword">if</span> (choice == <span class="string">"num"</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"你要修改哪个学号信息："</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">		P = Searchlist(num);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (choice == <span class="string">"name"</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"你要修改哪个学生信息："</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">		P = Searchlist(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//结构中暂未添加保存成绩的数组，暂不具体做修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>2020.4.8：<strong>完成项</strong>：目前只完成链表的创建，链表指定节点的删除，链表节点信息的查找</p>
<p><strong>运用C++新学的知识</strong>：函数重载，类的定义，类的构造函数与析构函数。</p>
]]></content>
      <categories>
        <category>程序开发</category>
      </categories>
      <tags>
        <tag>C/C++语言</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云CentOS8.0服务器宝塔安装失败，提示（setuptools installation failed）</title>
    <url>/2020/04/03/%E9%98%BF%E9%87%8C%E4%BA%91CentOS8-0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9D%E5%A1%94%E5%AE%89%E8%A3%85%E5%A4%B1%E8%B4%A5%EF%BC%8C%E6%8F%90%E7%A4%BA%EF%BC%88setuptools-installation-failed%EF%BC%89/</url>
    <content><![CDATA[<p>对于想要搭建一些个人网站的小伙伴们，苦于阿里云繁琐的设置界面无从下手，推荐一个简洁的控制面板：宝塔面板</p>
<a id="more"></a>
<p>推荐教程：[阿里云服务器安装宝塔面板图文教程]（<a href="https://developer.aliyun.com/ask/233242?spm=a2c6h.13524658）" target="_blank" rel="noopener">https://developer.aliyun.com/ask/233242?spm=a2c6h.13524658）</a></p>
<h1 id="我在安装宝塔服务器时，安装突然终止，然后给出"><a href="#我在安装宝塔服务器时，安装突然终止，然后给出" class="headerlink" title="我在安装宝塔服务器时，安装突然终止，然后给出"></a>我在安装宝塔服务器时，安装突然终止，然后给出</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setuptools installation failed</span><br></pre></td></tr></table></figure>
<h1 id="我想到的可能的解决办法："><a href="#我想到的可能的解决办法：" class="headerlink" title="我想到的可能的解决办法："></a>我想到的可能的解决办法：</h1><p>1.重新初始化我的云盘<br>2.重装我的云服务器系统</p>
<h3 id="办法一：重新初始化我的云盘"><a href="#办法一：重新初始化我的云盘" class="headerlink" title="办法一：重新初始化我的云盘"></a>办法一：重新初始化我的云盘</h3><p>1.关闭你的云服务器（一定要关，不然他不让你初始化）<br>2.点击本实例磁盘<br><img src="http://www.morenmoren.com/22548835-1b744f8ca09c6a6d.png" alt="进入初始化界面"><br>3.点击重新初始化，再安装一次宝塔面板即可<br><img src="http://www.morenmoren.com/22548835-43b129a4f77972ee.png" alt="云存储"></p>
<h3 id="办法二：重装我的云服务器系统"><a href="#办法二：重装我的云服务器系统" class="headerlink" title="办法二：重装我的云服务器系统"></a>办法二：重装我的云服务器系统</h3><p>我是先完成的重新初始化磁盘，发现安装还是失败了，于是我想到了重装系统，成功安装了宝塔面板。我所使用的时CentOS 8.0系统,也就是阿里云服务器上centos的最新版本，我认为也许是新版并不兼容宝塔面板。下面是解决办法：</p>
<p>1.如上：关闭云服务器（不再做演示）</p>
<p>2.在实例详细页面，往下翻找到配置信息，点击更多，点击更换操作系统进入更改页面<br><img src="http://www.morenmoren.com/22548835-a5d0f9b89f3c0a24.png" alt=""></p>
<p><img src="http://q86xw0tu1.bkt.clouddn.com/22548835-dff63787afe67517.png" alt="更改页面"><br>3.在这里我们还是选择centos系统，但是我们将版本选择为7.5 64位（当然也可以选择其他版本，我没试过），然后再重新设置一下密码，远程连接需要用到。</p>
<p>4.点击确认更换，然后系统重装完成，再安装宝塔面板（我成功安装了）。</p>
<h5 id="如果仍然没有解决问题，很抱歉耽搁你的时间了。。。。。。"><a href="#如果仍然没有解决问题，很抱歉耽搁你的时间了。。。。。。" class="headerlink" title="如果仍然没有解决问题，很抱歉耽搁你的时间了。。。。。。"></a>如果仍然没有解决问题，很抱歉耽搁你的时间了。。。。。。</h5>]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
        <tag>问题解决</tag>
      </tags>
  </entry>
</search>
